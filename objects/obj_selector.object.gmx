<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-9000000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Varibale Declarations - start
draw = false
refreshed = false
//Variable Declarations - end

unit_space = 75
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//DBG NEW CODE - Create paths that do not all converge on one point

tempstring = "obj_p" + string(global.PlayerId) + "_unit_parent";
tempobj = asset_get_index(tempstring);

//Takes all relevant objects and put it into sortable datastructure...
//Fix this algorithm, make it grid based similar to starcraft 2
var selection_grid = ds_grid_create(1,global.number_of_selected)
var k = 0

with (tempobj) {
    if (selected &amp;&amp; ispeon) {
        ds_grid_set(selection_grid,0,k,id)
        k++
    }
}

if (k != global.number_of_selected) {
    exit
}

// END SELECTION ALGORITHM

tmp_res = instance_place(mouse_x,mouse_y,obj_resource_parent);

var dx, dy, path
col_width = obj_map.map_col_width
row_height = obj_map.map_row_height
unit_tester = ds_grid_get(selection_grid,0,0) //Gets first unit's ID
break_for = false


for (i = 1; i&lt;20;i++) {
    dx = dy = i

    while (dx != -dy) {
        gx = dx + (tmp_res.x div col_width)
        gy = dy + (tmp_res.y div row_height)
        if (as_map_getcell(obj_map.map,gx/col_width,gx/row_height)) {
            path = as_path_create(obj_map.map,unit_tester.x div col_width,unit_tester.y div row_height,gx, gy,1,2,-1);
            if (as_path_length(path) &gt; 0) {
                break;
            }
            as_path_destroy(path)
        }
        dy--
    }
    if (break_for) {break;}
    
    while (-dx != -dy) {
        gx = dx + (tmp_res.x div col_width)
        gy = dy + (tmp_res.y div row_height)
        if (as_map_getcell(obj_map.map,gx/col_width,gx/row_height)) {
            path = as_path_create(obj_map.map,unit_tester.x div col_width,unit_tester.y div row_height,gx div col_width, gy div row_height,1,2,-1);
            if (as_path_length(path) &gt; 0) {
                break;
            }
            as_path_destroy(path)
        }
        dx--
    }
    if (break_for) {break;}
    
    while (-dx != dy) {
        gx = dx + (tmp_res.x div col_width)
        gy = dy + (tmp_res.y div row_height)
        if (as_map_getcell(obj_map.map,gx/col_width,gx/row_height)) {
            path = as_path_create(obj_map.map,unit_tester.x div col_width,unit_tester.y div row_height,gx div col_width, gy div row_height,1,2,-1);
            if (as_path_length(path) &gt; 0) {
                break;
            }
            as_path_destroy(path)
        }
        dy++
    }
    if (break_for) {break;}
    
    while (dx != dy) {
        gx = dx + (tmp_res.x div col_width)
        gy = dy + (tmp_res.y div row_height)
        if (as_map_getcell(obj_map.map,gx/col_width,gx/row_height)) {
            path = as_path_create(obj_map.map,unit_tester.x div col_width,unit_tester.y div row_height,gx div col_width, gy div row_height,1,2,-1);
            if (as_path_length(path) &gt; 0) {
                break;
            }
            as_path_destroy(path)
        }
        dx++
    }
    if (break_for) {break;}
    
}

for (i = 0; i&lt; ds_grid_height(selection_grid) ; i++) {
    unit_inst = ds_grid_get(selection_grid,0,i)
    unit_inst.move_x = gx * col_width
    unit_inst.move_y = gy * row_height
    unit_inst.alarm[5] = 1
}


ds_grid_destroy(selection_grid)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//DBG NEW CODE - Create paths that do not all converge on one point

for (m = 0; m&lt;2; m++) {

    switch (m) {
        case 0:
            tempstring = "obj_p" + string(global.PlayerId) + "_unit_parent";
            tempobj = asset_get_index(tempstring);
            break;
        case 1:
            //For AIR based troops
            tempstring = "obj_p" + string(global.PlayerId) + "_unit_parent_flying";
            tempobj = asset_get_index(tempstring);
            break;
    }
    
    //Takes all relevant objects and put it into sortable datastructure...
    //Fix this algorithm, make it grid based similar to starcraft 2
    var selection_grid = ds_grid_create(5,global.number_of_selected)
    var k = 0
    var n = 0 //Replacing all global.number_of_selected's with "n"
    
    with (tempobj) {
        if (selected &gt; 0) {
            ds_grid_set(selection_grid,0,n,id)
            ds_grid_set(selection_grid,1,n,x)
            ds_grid_set(selection_grid,2,n,y)
            n++
        }
    }
    
    /*
    if (k != global.number_of_selected) {
        continue//exit;
    }
    */
    if (n == 0) {
        continue
    }
        
    //Resize the grid to k (since flying units now are messing algorithm up, this fixes
    ds_grid_resize(selection_grid,5,n)
    
    //Algorithm for determining how many spaces in grid there are
    y_blocks = floor(sqrt(n))   //How many ROWS
    x_blocks = y_blocks                                 //How many COLUMNS
    
    if (n &gt; (y_blocks * y_blocks)) {
        x_blocks++
    }
    
    if (n - (y_blocks * y_blocks) - y_blocks) &gt; 0 {
        y_blocks++
    }
    
    //Algorithm for putting units in order
    k = 0
    ds_grid_sort(selection_grid,2,true) //Sorts grid by ascending order of y coords
    for (i = 0;i&lt;y_blocks;i++) {
        for (j = 0; j&lt;x_blocks;j++) {
            ds_grid_set(selection_grid,3,k,i * x_blocks)
            k++
            if k &gt;= n {
                i = y_blocks
                j = x_blocks
                //Equivalent of breaking out
            }
        }
    }
    k = 0
    ds_grid_sort(selection_grid,1,true) //Sorts grid by ascending order of x coords
    for (i = 0;i&lt;x_blocks;i++) {
        for (j = 0; j &lt; y_blocks;j++) {
            y_val = ds_grid_get(selection_grid,3,k) + i
            ds_grid_set(selection_grid,3,k,y_val) //Adding x and weighted y together
            k++
            if k &gt;= n {
                i = x_blocks
                j = y_blocks
                //Equivalent of breaking out
            }
        }
    }
    
    ds_grid_sort(selection_grid,3,true)
    
    
    //Change mouse_x and mouse_y to be center of this new grid
    x_grid_top_left = mouse_x - (((x_blocks-1) * unit_space) / 2)
    y_grid_top_left = mouse_y - (((y_blocks-1) * unit_space) / 2)
    
    if global.mapMovement == 1 {
        x_grid_top_left = global.mapMove_x
        y_grid_top_left = global.mapMove_y
    }
    //Now put all move_x's and move_y's in grid pattern
    
    unit_sel = 0
    for (i=0;i&lt;y_blocks;i++) {
        for (j=0;j&lt;x_blocks;j++) {
            unit_inst = ds_grid_get(selection_grid,0,unit_sel)
            unit_inst.move_x = x_grid_top_left + (j * unit_space)
            unit_inst.move_y = y_grid_top_left + (i * unit_space)
            unit_inst.alarm[5] = 1
            unit_sel++;
            if (unit_sel &gt; n - 1) {
                break;
            }
        }
        if (unit_sel &gt; n - 1) {
            break;
        }
    }

    ds_grid_destroy(selection_grid)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>refreshed = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//advanced movement
//vars row: (-), column: (|), remainder
if (global.number_of_selected &gt;= 2)
{



temp_root = ceil(sqrt(global.number_of_selected));
remainder = (global.number_of_selected mod temp_root);
row = temp_root;
column = temp_root;
//get rid of remainder
extra = 0;
while (remainder != 0)
{
    if remainder &gt;= row
    {
        remainder -= row;
        column += 1;
    }
    else
    {
        extra = remainder;
        remainder = 0;
    }
}

//just in case
column += 1;
row +=1;
//create array
for (i=1;i&lt;column;i+=1)
{
    for (z=1;z&lt;row;z+=1)
    {
        spotx[i,z] = i*20;
        spoty[i,z] = z*20;
        spotav[i,z] = false;
    }
}
j = column + 1;
for (p=1;p&lt;extra;p+=1)
{
    spotx[j,p] = j*20;
    spoty[j,p] = p*20;
    spotav[j,p] = false;
}
//get centre point
stockx = 0;
stocky = 0;
with (obj_unit_parent)
{
    if selected = true
    {
        obj_selector.stockx += x;
        obj_selector.stocky += y;
    }
}
centrex = stockx/global.number_of_selected;
centrey = stocky/global.number_of_selected;

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//selection - start
draw = false;
//selection - end

//advanced movement
alarm[1]=1;</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>alarm[0]=1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="54">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//DBG NEW CODE - Create paths that do not all converge on one point
if (instance_place(mouse_x,mouse_y,obj_resource_parent) &amp;&amp; global.mapMovement == 0) {
    alarm[4] = 1 //Alarm stores algorithm for resources
}

else {
    alarm[3] = 1; //Alarm stores algorithm for moving and attacking
}
/*
tempstring = "obj_p" + string(global.PlayerId) + "_unit_parent";
tempobj = asset_get_index(tempstring);

//Takes all relevant objects and put it into sortable datastructure...
//Fix this algorithm, make it grid based similar to starcraft 2
var selection_grid = ds_grid_create(5,global.number_of_selected)
var k = 0

with (tempobj) {
    if (selected &gt; 0) {
        ds_grid_set(selection_grid,0,k,id)
        ds_grid_set(selection_grid,1,k,x)
        ds_grid_set(selection_grid,2,k,y)
        k++
    }
}

if (k != global.number_of_selected) {
    exit
}



//Algorithm for determining how many spaces in grid there are
y_blocks = floor(sqrt(global.number_of_selected))   //How many ROWS
x_blocks = y_blocks                                 //How many COLUMNS

if (global.number_of_selected &gt; (y_blocks * y_blocks)) {
    x_blocks++
}

if (global.number_of_selected - (y_blocks * y_blocks) - y_blocks) &gt; 0 {
    y_blocks++
}

//Algorithm for putting units in order
k = 0
ds_grid_sort(selection_grid,2,true) //Sorts grid by ascending order of y coords
for (i = 0;i&lt;y_blocks;i++) {
    for (j = 0; j&lt;x_blocks;j++) {
        ds_grid_set(selection_grid,3,k,i * x_blocks)
        k++
        if k &gt; global.number_of_selected {
            i = y_blocks
            j = x_blocks
            //Equivalent of breaking out
        }
    }
}
k = 0
ds_grid_sort(selection_grid,1,true) //Sorts grid by ascending order of x coords
for (i = 0;i&lt;x_blocks;i++) {
    for (j = 0; j &lt; y_blocks;j++) {
        y_val = ds_grid_get(selection_grid,3,k) + i
        ds_grid_set(selection_grid,3,k,y_val) //Adding x and weighted y together
        k++
        if k &gt; global.number_of_selected {
            i = x_blocks
            j = y_blocks
            //Equivalent of breaking out
        }
    }
}

ds_grid_sort(selection_grid,3,true)


//Change mouse_x and mouse_y to be center of this new grid
x_grid_top_left = mouse_x - ((x_blocks * unit_space) / 8)
y_grid_top_left = mouse_y - ((y_blocks * unit_space) / 8)

if global.mapMovement == 1 {
    x_grid_top_left = global.mapMove_x
    y_grid_top_left = global.mapMove_y
}
//Now put all move_x's and move_y's in grid pattern

unit_sel = 0
for (i=0;i&lt;y_blocks;i++) {
    for (j=0;j&lt;x_blocks;j++) {
        unit_inst = ds_grid_get(selection_grid,0,unit_sel)
        unit_inst.move_x = x_grid_top_left + (j * unit_space)
        unit_inst.move_y = y_grid_top_left + (i * unit_space)
        unit_inst.alarm[5] = 1
        unit_sel++;
        if (unit_sel &gt; global.number_of_selected - 1) {
            break;
        }
    }
    if (unit_sel &gt; global.number_of_selected - 1) {
        break;
    }
}

ds_grid_destroy(selection_grid)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if mouse is not in hud - start 
//DisBeGee Edit: Mapmovement
if ((mouse_y - view_yview[0]) &lt;= obj_HUD.border || global.mapMovement == 1)
{


//selection - start
{
    draw = true;
    mousex = mouse_x;
    mousey = mouse_y;
}
//selection - end



}
//if mouse is not in hud
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//selection - start
if draw = true
{
    draw_set_alpha(1);
    draw_set_color(c_lime);
    draw_rectangle(mousex,mousey,mouse_x,mouse_y,true);
}
//selection - end
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
