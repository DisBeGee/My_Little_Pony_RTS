<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_man_mask</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_unit_parent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/* - Setup - */
/*var*/ selected = false; // generally dont touch any of the following
/*var*/ //selectcx1 = -14;
/*var*/ //selectcx2 = 14;
/*var*/ //selectcy1 = 9;
/*var*/ //selectcy2 = 21;
/*var*/ able_to_move = false;
/*var*/ move_x = 0;
/*var*/ move_y = 0;
/*var*/ direction = 270;
/*var*/ image_speed = 0.5;
/*var*/ state = 0 /* 0 is standing, 1 is walking, 2 is attacking, 3 is gathering (peon only), 4 is special, 5 is walking while holding resources, 6 is building, 7 is for casting*/
/*var*/ //ally_units = obj_unit_parent;
/*var*/ //unit_pic = spr_man_pic; // the pic for the unit on the hud
/*var*/ 
/* - Setup version 2- */
/*var*/ //y_offset = 7; // this offest makes it so the centre of the unit is somewhere near its feet, to give the isometric feel
/*var*/ //foot_radius = 10; //the radius of the circle under the units feet, which is used for pushing against other units
/*var*/ _prevx = 0; // these two variables are used for telling if the unit is standing still NOTE!! i just relised that gamemaker has built in varibales that do EXACTLY this, so use them instead if you want
/*var*/ _prevy = 0;
/*var*/ //push_rate = 2; // this is the speed at which the units push against eachother, when they pile up on top of each other
/*var*/ //alarm[4] = 5; // This DOESNT have to be alarm 4, but make sure you fix the other vaiable to make it work for a different alram
/*var*/ //bump_delay = 30; //how long after being INITIALLY bumped, to walk back to original position
/*var*/ been_bumped = false;
/*var*/ 
/* - Setup version 3: Ailments- */
/*var*/ //ailment_pos = -20 // where the icons ill show up relatice to the centre of the unit
/*var*/ //ailment_size = 16; //the general size of the icons
/*var*/ //ailment_gap = 3; //the gap between the ailments, if there ismore than one
/*var*/ ailment_count = 0; // the number of ailments that the unit is currently suffering from
/*var*/ ailment_list[0] = spr_temp; //this holds the list of sprites of ailmets that the unit is duffering from. Yeah, don't touch this one
/*var*/ 
/*var*/ stunned = false; //stun
/*var*/ stun_counter = 0; //how much longer this guy willbe stunned for
/*var*/ stun_spr = spr_ailment_stun; //icon of the stun
/*var*/ 
/*var*/ scilenced = false; //scilence
/*var*/ scilence_counter = 0; //how much longer this guy will be scilenced for
/*var*/ scilence_spr = spr_ailment_scilence; //icon of the scilence
/*var*/ 
/*var*/ //You can add more of your own here
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/* - Stats - */
/*var*/ //unit_speed = 3;
/*var*/ //unit_area = 30; 
/*var*/ //unit_hp = 20;
/*var*/ //unit_hp_max = 20;
/*var*/ //unit_damage = 3;
/*var*/ //unit_damage_range = 1;
/*var*/ //unit_name = "Villi"
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/* - Graphics - */
/*var*/ g_name = "spr_man_"; // dun use this bruddah
/*var*/ stand_anim = "";
/*var*/ walk_anim = "_walk";
/*var*/ attack_anim = "_attack"
/*var*/ //gather_anim =
/*var*/ 
/* initializing sprites */
/*var*/ //state_anim[0,0] = spr_man_down;
/*var*/ //state_anim[0,1] = spr_man_downright;
/*var*/ //state_anim[0,2] = spr_man_right;
/*var*/ //state_anim[0,3] = spr_man_upright;
/*var*/ //state_anim[0,4] = spr_man_up;
/*var*/ //state_anim[0,5] = spr_man_upleft;
/*var*/ //state_anim[0,6] = spr_man_left;
/*var*/ //state_anim[0,7] = spr_man_downleft;
/*var*/ //state_anim[1,0] = spr_man_down_walk; // for walking
/*var*/ //state_anim[1,1] = spr_man_downright_walk;
/*var*/ //state_anim[1,2] = spr_man_right_walk;
/*var*/ //state_anim[1,3] = spr_man_upright_walk;
/*var*/ //state_anim[1,4] = spr_man_up_walk;
/*var*/ //state_anim[1,5] = spr_man_upleft_walk;
/*var*/ //state_anim[1,6] = spr_man_left_walk;
/*var*/ //state_anim[1,7] = spr_man_downleft_walk;
/*var*/ //state_anim[2,0] = spr_man_down_attack; //for attacking
/*var*/ //state_anim[2,1] = spr_man_downright_attack;
/*var*/ //state_anim[2,2] = spr_man_right_attack;
/*var*/ //state_anim[2,3] = spr_man_upright_attack;
/*var*/ //state_anim[2,4] = spr_man_up_attack;
/*var*/ //state_anim[2,5] = spr_man_upleft_attack;
/*var*/ //state_anim[2,6] = spr_man_left_attack;
/*var*/ //state_anim[2,7] = spr_man_downleft_attack;
/*var*/ //state_anim[3,0] = spr_man_down_attack; // the following should be for the gathering animation
/*var*/ //state_anim[3,1] = spr_man_downright_attack;
/*var*/ //state_anim[3,2] = spr_man_right_attack;
/*var*/ //state_anim[3,3] = spr_man_upright_attack;
/*var*/ //state_anim[3,4] = spr_man_up_attack;
/*var*/ //state_anim[3,5] = spr_man_upleft_attack;
/*var*/ //state_anim[3,6] = spr_man_left_attack;
/*var*/ //state_anim[3,7] = spr_man_downleft_attack;

/*var*/ //state_anim[5,0] = spr_man_down_walk; // for walking while holding resources
/*var*/ //state_anim[5,1] = spr_man_downright_walk;
/*var*/ //state_anim[5,2] = spr_man_right_walk;
/*var*/ //state_anim[5,3] = spr_man_upright_walk;
/*var*/ //state_anim[5,4] = spr_man_up_walk;
/*var*/ //state_anim[5,5] = spr_man_upleft_walk;
/*var*/ //state_anim[5,6] = spr_man_left_walk;
/*var*/ //state_anim[5,7] = spr_man_downleft_walk;

/*var*/ //state_anim[6,0] = spr_man_down_attack; // for building
/*var*/ //state_anim[6,1] = spr_man_downright_attack;
/*var*/ //state_anim[6,2] = spr_man_right_attack;
/*var*/ //state_anim[6,3] = spr_man_upright_attack;
/*var*/ //state_anim[6,4] = spr_man_up_attack;
/*var*/ //state_anim[6,5] = spr_man_upleft_attack;
/*var*/ //state_anim[6,6] = spr_man_left_attack;
/*var*/ //state_anim[6,7] = spr_man_downleft_attack;

/*var*/ //state_anim[7,0] = spr_man_cast_down; // for casting animation
/*var*/ //state_anim[7,1] = spr_man_cast_downright;
/*var*/ //state_anim[7,2] = spr_man_cast_right;
/*var*/ //state_anim[7,3] = spr_man_cast_upright;
/*var*/ //state_anim[7,4] = spr_man_cast_up;
/*var*/ //state_anim[7,5] = spr_man_cast_upleft;
/*var*/ //state_anim[7,6] = spr_man_cast_left;
/*var*/ //state_anim[7,7] = spr_man_cast_downleft;
/* - Peon Attributes - */
/*var*/ //ispeon = true; //if able to gather resources
/*var*/ gathering = false; //if is in gathering routine
/*var*/ can_gather = true;
/*var*/ //gather_rate = 1; // how much of the resource the unit gathers per hit
/*var*/ //gathercooldown = 17; //cooldown of gather attack
/*var*/ holding_resources = false; // if is holding resources
/*var*/ res_hold1 = 0; //amount of resource1 it is currently holding
/*var*/ res_hold2 = 0; //amount of resource2 it is currently holding
/*var*/ res_hold3 = 0; //amount of resource3 it is currently holding
/*var*/ res_hold4 = 0; //amount of resource4 it is currently holding
/*var*/ res_hold5 = 0; //amount of resource5 it is currently holding
/*var*/ res_hold_lim = 10; //the max amount of resources it can carry at once
/*var*/ res_x = 99;
/*var*/ res_y = 99;
/*var*/ grout_type = 99; //collection type (0 = mining, 1 = collecting)
/*var*/ grout_collect = 99; //resource variable eg. res_hold2 (NO!)
/*var*/ grout_resnum = 99; // the one above
/*var*/ grout_target = 99; //resource object
/*var*/ grout_deposit = 99; //house to dump all the resources
/*var*/ grout_object = 99; // object of target
/*var*/ //grout_peonhouse = peonhouse; //the building that the unit deposits resources to
/*var*/ //gath_spr_length = 2; // how long or how many diff sprites your animation has
/*var*/ //gath_spr_hit = 1; //the image num where the unit would of hit the target
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/* - Building - */
/*var*/ //iscratorer = true; //if it can build buildings
/*var*/ buildn_x = 0;
/*var*/ buildn_y = 0;
/*var*/ build_power = 2; // how fast this guy builds
/*var*/ build_target = 99; //the builing that is targeted to built
/*var*/ build_ing = false; //if the unit is in the process of building or not
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/* - Atakking - */
/*var*/ attacking = false;
/*var*/ //attack_type = 0; //0 = close, 1 = long ranged, 2 = other
/*var*/ //attack_range = 2; // was 2 please change back  - FOR BOTH RANGED AND MELEE
/*var*/ nearest_enemy = 99;
/*var*/ attack_target = 99;
/*var*/ //autoattack_range = 200; // -- please change back to 250
/*var*/ attack_mode = false;
/*var*/ tmp_enmy = 99;
/*var*/ //attack_cooldown = 20; // -- was orriginally 10, but a bit too fast. 20 seem decent
/*var*/ can_attack = true;
/*var*/ //atk_spr_length = 2; // how long or how many diff sprites you attack animation has - MELEE ONLY
/*var*/ //atk_spr_hit = 1; // for attempt 2, the image num where the unit would of hit the target - MELEE ONLY
/*var*/ //attack_range_obj = obj_projectile_template; // the object that is your ranged projectile - RANGED ONLY
/*var*/ attack_range_range = 160; // range of your ranged attack OI!! plox dont use this - use attack_range - RANGED ONLY
/*var*/ //attack_range_speed = 9; // speed of the projectile - RANGED ONLY
/*var*/ //attack_range_AOE = 1; // area of effect of projectile - RANGED ONLY
/*var*/ //attackable_units = obj_unit_enemy_parent; // units that are enemys - the ones that are auto attacked
/*var*/ //atk_spr_rng_hit = 1; // the image num where the unit would of shot the projectile - RANGED ONLY
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/* - Spell Casting - */
/*var*/ cast_range = 99;  //generally do NOT touch this stuff. PLIAS!!
/*var*/ cast_cooldown = 99;
/*var*/ cast_type = 99;
/*var*/ cast_damage = 99;
/*var*/ cast_target_obj = 99;
/*var*/ cast_targetx = 99;
/*var*/ cast_targety = 99;
/*var*/ cast_targettype = 99;
/*var*/ cast_object = 99;
/*var*/ cast_cost = 99;
/*var*/ cast_spellname = 99;
/*var*/ cast_time = 99;
/*var*/ cast_proj_speed = 99;
/*var*/ cast_proj_aoe = 99;
/*var*/ cast = false; // this is the flag that says whether or not the unit has been ordered to cast the spell
/*var*/ casting = false; //this is whether the ACTUAL casting is taking place
/*var*/ cast_button_index = 99;
/*var*/ cast_code = 99;
/*var*/ 
/* - HUD - */
/*var*/ //hud_gen_s1 = obj_button_test_message;
/*var*/ //hud_gen_s2 = obj_button_template;
/*var*/ //hud_gen_s3 = obj_button_template;
/*var*/ //hud_gen_s4 = obj_button_template;
/*var*/ //hud_gen_s5 = obj_button_template;
/*var*/ //hud_gen_s6 = obj_button_template;
/*var*/ //hud_gen_s7 = obj_button_template;
/*var*/ //hud_gen_s8 = obj_button_template;
/*var*/ //hud_gen_s9 = obj_button_template;
/*var*/ //hud_gen_s10 = obj_button_template;
/*var*/ //hud_gen_s11 = obj_button_template;
/*var*/ //hud_gen_s12 = obj_button_template;
/*var*/ //hud_gen_s13 = obj_button_template;
/*var*/ //hud_gen_s14 = obj_button_spell_scilence;
/*var*/ //hud_gen_s15 = obj_button_spell_cocktail;
/*var*/ //hud_gen_s16 = obj_button_spell_clight;
/*var*/ //hud_gen_s17 = obj_button_heal;
/*var*/ //hud_gen_s18 = obj_button_spell1_template;
/*var*/ //hud_build_s1 = 99;
/*var*/ //hud_build_s2 = 99;
/*var*/ //hud_build_s3 = 99;
/*var*/ //hud_build_s4 = 99;
/*var*/ //hud_build_s5 = 99;
/*var*/ //hud_build_s6 = 99;
/*var*/ //hud_build_s7 = 99;
/*var*/ //hud_build_s8 = 99;
/*var*/ //hud_build_s9 = 99;
/*var*/ //hud_build_s10 = 99;
/*var*/ //hud_build_s11 = 99;
/*var*/ //hud_build_s12 = 99;
/*var*/ //hud_build_s13 = 99;
/*var*/ //hud_build_s14 = 99;
/*var*/ //hud_build_s15 = 99;
/*var*/ //hud_build_s16 = 99;
/*var*/ //hud_build_s17 = 99;
/*var*/ //hud_build_s18 = 99;
/*var*/ 
/*var*/ 
/* - for HUD - */
/* - for Health Bar - */
/*var*/ //healthbar_x = -14;
/*var*/ //healthbar_y = -26;
/*var*/ //healthbar_length = 28;
/*var*/ //healthbar_height = 4;
/*var*/ //healthbar_fg_col = c_lime;
/*var*/ //healthbar_bg_col = c_black;
/*var*/ 
/* - For Spell Cooldowns - */
for (i=0;i&lt;18;i+=1) //initialise cooldowns for buttons
{
    hud_button_cooldown_index[i] = 0;
}
/*var*/ is_is_building = false;
/* - Misc - */
/*var*/ stringx = "";
/* -  - */</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// for moving back into formation after being bumped away
move_x = bump_x;
move_y = bump_y;
able_to_move = true;
been_bumped = false;</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>alarm[4] = 5; //If your not using alarm 4, remember to change this

//check if stunned
if (stunned==false)
{



//Unit bumping (so they dont pile up on each other) - start
if (_prevx==x &amp;&amp; _prevy==y) 
{
    instance_deactivate_object(self);
    ally_nrst = instance_nearest(x, y+y_offset, all);
    instance_activate_object(self);
    if (instance_exists(ally_nrst) &amp;&amp; object_get_parent(ally_nrst.object_index)!=obj_projectile_parent )
    {
        if (distance_to_point(ally_nrst.x, ally_nrst.y)&lt;=foot_radius)
        {
            //new stuff (Moving back into formation if was bumped) - start
            if ((ally_nrst.x == ally_nrst.xprevious) &amp;&amp; (ally_nrst.y == ally_nrst.yprevious))   //check if the unit that bumped into this one is moving
            {
                if (been_bumped = false) //if not already bumped
                {
                    bump_x = x;
                    bump_y = y;
                    alarm[5] = bump_delay;
                    been_bumped = true;
                }
            }  
            //new stuff (Moving back into formation if was bumped) - end
            anglay = point_direction(ally_nrst.x, ally_nrst.y, x, y+y_offset); // this is in degress
            anglay_r = (anglay*pi)/180; //convert to radians
            goto_x = x + push_rate*(cos(anglay_r));
            goto_y = y + push_rate*(-sin(anglay_r));
            temp_len_x = foot_radius*(cos(pi/2));
            temp_len_y = foot_radius*(-sin(pi/2))
            if ((place_free(goto_x+temp_len_x, goto_y+temp_len_y))&amp;&amp;
                (place_free(goto_x+temp_len_x, goto_y-temp_len_y))&amp;&amp;
                (place_free(goto_x-temp_len_x, goto_y+temp_len_y))&amp;&amp;
                (place_free(goto_x-temp_len_x, goto_y-temp_len_y)))
            {
                x = goto_x;
                y = goto_y;
                alarm[4]=1;
            }
        }
    }
}
_prevx = x;
_prevy = y;
//Unit bumping (so they dont pile up on each other) - start



//check if stunned
}</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//this is for cast time
//execute_string(cast_code);
script_execute(cast_code);
casting = false;
cast = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//todo with movement
/*if able_to_move = true || gathering = true
{
//if move_x - instance_nearest(move_x,move_y,all).x &lt;= unit_area &amp;&amp; move_x - instance_nearest(move_x,move_y,all).x &gt;= (-1*unit_area) &amp;&amp; move_y - instance_nearest(move_x,move_y,all).y &lt;= unit_area &amp;&amp; move_y - instance_nearest(move_x,move_y,all).y &gt;= (-1*unit_area)
/*        if distance_to_object(poopoo) &lt;= 0
        {
            able_to_move = true;
            move_x = move_x + random(32) - random(32);
            move_y = move_y + random(32) - random(32);
        }
}*/</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>can_gather = true;</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>can_attack = true;</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>depth = -y</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Health - start
if unit_hp  &lt;= 0 
{ 
    if selected = true 
    { 
        selected = false;
        global.number_of_selected -= 1 
    } 
    //death animation here
    instance_create(x,y,obj_explo_2);
    instance_destroy(); 
}
else if (unit_hp &gt; unit_hp_max)
{
    unit_hp = unit_hp_max;
}
// Health - end

//Ailments - start
if (ailment_count &gt;0)
{
    //ailment ticks
    if (stun_counter &gt; 0)
    {
        stun_counter -= 1;
        //turn off everything!!
        /*able_to_move = false;
        cast = false;
        casting = false;
        attack_mode = false;
        gathering = false;
        build_ing = false;*/
    }
    else
    {
        if (stunned==true)
        {
            stunned = false;
            ailment_count -= 1;
        }
    }

    if (scilence_counter &gt; 0)
    {
        scilence_counter -= 1;
    }
    else
    {
        if (scilenced==true)
        {
            scilenced = false;
            ailment_count -= 1;
        }
    }
    //ailment ticks
    
    //ailments graphics
    trnmp_counter = 0;
    
    for (i=0;i&lt;ailment_count;i+=1) //reset list
    {
        ailment_list[i] = 99;
    }
    
    //add ailments into list
    if (stunned==true) { ailment_list[trnmp_counter]=stun_spr; trnmp_counter +=1 }
    if (scilenced==true) { ailment_list[trnmp_counter]=scilence_spr; trnmp_counter +=1 }
    
    //ailments graphics
}
//Ailments - end




//Check if stunned or similar - start
if (stunned==false)
{




//Moving - start
if able_to_move = true &amp;&amp; attack_mode = false &amp;&amp; build_ing = false &amp;&amp; cast == false
{
    mp_potential_step(move_x,move_y,unit_speed,false);
    state = 1;
}

/*if able_to_move = true &amp;&amp; gathering = true &amp;&amp; grout_collect = res_hold_lim // for resource gathering
{
    mp_potential_step(move_x,move_y,unit_speed,false);
    state = 5;
}*/

if x = move_x &amp;&amp; y = move_y and able_to_move = true
{
        able_to_move = false;
        state = 0;
}

//testing to see if this fixes bug - omg it does - and it also come with a 10 fps increase
if able_to_move = true || gathering = true
{
//testing to see if this fixes bug
    if instance_nearest(move_x,move_y,all) &amp;&amp; instance_nearest(move_x,move_y,all) != self.id //&amp;&amp; gathering = false
    {
        //if move_x - instance_nearest(move_x,move_y,all).x &lt;= unit_area &amp;&amp; move_x - instance_nearest(move_x,move_y,all).x &gt;= (-1*unit_area) &amp;&amp; move_y - instance_nearest(move_x,move_y,all).y &lt;= unit_area &amp;&amp; move_y - instance_nearest(move_x,move_y,all).y &gt;= (-1*unit_area)
        
        if distance_to_object(instance_nearest(move_x,move_y,all)) &lt;= 0
        {
            able_to_move = true;
            move_x = move_x + random(32) - random(32);
            move_y = move_y + random(32) - random(32);
        }
        //poopoo = instance_nearest(move_x,move_y,all);
        //alarm[2] = 20;
    }
//testing to see if this fixes bug
}
//testing to see if this fixes bug
//Moving - end

//Attacking - start
nearest_enemy = instance_nearest(x,y,attackable_units);
if able_to_move = false &amp;&amp; attack_mode = false &amp;&amp; gathering = false { state = 0; } //this is a fix - its stops the unit walking iif the enmy sunndenly disappears
//if able_to_move = false &amp;&amp; gathering = false { state = 0; } //this is a fix - same as above but for gathering

if able_to_move = false &amp;&amp; state = 0 &amp;&amp; attack_target = 99 &amp;&amp; attack_mode = false /* new */ &amp;&amp; build_ing = false /* new */ &amp;&amp; casting == false &amp;&amp; cast==false //setting target if doing nothing and enemy is close
{
    temp_enemy = nearest_enemy;
    if distance_to_object(temp_enemy) &lt; autoattack_range
    {
        if instance_exists(temp_enemy)
        {
            attack_target = temp_enemy;
            tmp_enmy = temp_enemy;
        }
    }
}

if instance_exists(attack_target) = 0
{
    attack_target = 99;
    attack_mode = false;
}

if attack_target != 99 //setting unit into attack mode
{
    attack_mode = true // attacking
}

if attack_mode = true &amp;&amp; distance_to_object(attack_target) &gt; attack_range &amp;&amp; casting == false &amp;&amp; cast==false
{
    mp_potential_step(attack_target.x,attack_target.y,unit_speed,false);
    state = 1;
}
//actual attack cycle **
if attack_mode = true &amp;&amp; distance_to_object(attack_target) &lt;= attack_range &amp;&amp; casting == false
{
    if instance_exists(attack_target)
    {
        direction = point_direction(x,y,attack_target.x,attack_target.y); //makes them look at the bloody enemy
        switch (attack_type)
        {
            case 0:
            {
                if can_attack = true
                {
                    alarm[0] = attack_cooldown;
                    //tmp_enmy.unit_hp -= unit_damage; // -- this is for attempt 2 (NO!! IT HAS BEEN MOVED DOWN, i think)
                    can_attack = false;
                    /* --  play attack animation here please  -- */
                    //atempt 1 - start (still keep for attempt 2)
                    state = 2;
                    image_index = 0;
                    image_speed = 0.5;
                    //atemp1 - end
                }
            }
            break;
        
            case 1:
            {
                if can_attack = true
                {
                    alarm[0] = attack_cooldown;
                    can_attack = false;
                    state = 2;
                    image_index = 0;
                    image_speed = 0.5;
//moved down        //actuall ranged stuff goes here
//so you would be   //tmp_rng = instance_create(x,y,attack_range_obj);
//able to chose when//tmp_rng.fastness = attack_range_speed;
//the proj was shot //tmp_rng.targetx = tmp_enmy.x;//to make this homeing just use tmp_enemy.x in the projectile object
//                  //tmp_rng.targety = tmp_enmy.y;//to make this homeing just use tmp_enemy.x in the projectile object
//                  //tmp_rng.target = tmp_enmy;
                    //tmp_rng.damage = unit_damage_range;
                    //tmp_rng.aoe = attack_range_AOE;
                    //tmp_rng.init_dir = direction;
                }
            }
            break;
        
            case 2:
            {
            }
            break;
        }
    }
    //do to with attack animimations looping and stopping
    switch (attack_type)
    {
        case 0: // melee or close
        {
            //attampt 1 - start (still keep for attempt 2)
            if state = 2 &amp;&amp; image_index = atk_spr_length
            {
                state = 0;
                image_speed = 0;
            }
            //attempt 1 - end
            //attampt 2 - start
            if state = 2 &amp;&amp; image_index = atk_spr_hit
            {
                attack_target.unit_hp -= unit_damage;
            }
            //attempt 2 - end
        }
        break;
        case 1: // long range attacks
        {
            if state = 2 &amp;&amp; image_index = atk_spr_length
            {
                state = 0;
                image_speed = 0;
            }
            if state = 2 &amp;&amp; image_index = atk_spr_rng_hit
            {
            //actuall ranged stuff goes here
                tmp_rng = instance_create(x,y,attack_range_obj);
                tmp_rng.fastness = attack_range_speed;
                tmp_rng.targetx = attack_target.x;//to make this homeing just use tmp_enemy.x in the projectile object
                tmp_rng.targety = attack_target.y;//to make this homeing just use tmp_enemy.x in the projectile object
                tmp_rng.target = attack_target;
                tmp_rng.damage = unit_damage_range;
                tmp_rng.aoe = attack_range_AOE;
                tmp_rng.init_dir = direction;
            }
        }
    }
}
//actual attack cycle **
//Attacking - end

//Gathering - start
if ispeon = true &amp;&amp; gathering = true
{
    if holding_resources = true
    {
        if grout_collect &lt; res_hold_lim
        {
            if instance_exists(grout_target)
            {
                move_x = res_x;
                move_y = res_y;
                able_to_move = true;
                if distance_to_object(grout_target) &lt;= grout_target.area_size
                {
                    able_to_move = false;
                    
                    if can_gather = true // ACUTAL Gather Cycle *************** start
                    {
                        alarm[1] = gathercooldown;
                        can_gather = false;
                        holding_resources = true;
                        state = 3;
                        image_index = 0;
                        image_speed = 0.5;
                    }     
                        switch (grout_type) // to do with animations
                        {
                        case 0:
                            {
                                if state = 3 &amp;&amp; image_index = gath_spr_length
                                {
                                    state = 0;
                                    image_speed = 0;
                                }
                                if state = 3 &amp;&amp; image_index = gath_spr_hit
                                {
                                    grout_target.resource_amount -= gather_rate;
                                    grout_collect += gather_rate;
                                    if grout_target.resource_amount &lt;= 0
                                    {
                                        with(grout_target){instance_destroy();}
                                    }
                                }
                            }
                            break;
                            case 1:
                            {
                                grout_target.resource_amount -= res_hold_lim;
                                grout_collect += res_hold_lim;
                                if grout_target.resource_amount &lt;= 0
                                {
                                    with(grout_target){instance_destroy();}
                                }
                            }
                            break;
                        }
                           // ACUTAL Gather Cycle *************** end
                }
            }
        }
        else
        if grout_collect &gt;= res_hold_lim
        {
            if instance_exists(grout_deposit)
            {
                move_x = grout_deposit.x
                move_y = grout_deposit.y
                able_to_move = true;
                state = 5;
                if distance_to_object(grout_deposit) &lt;= grout_deposit.area_size
                {
                    {
                        /*switch(grout_resnum)
                        {
                            case 1:{res_hold1 = grout_collect;}break;
                            case 2:{res_hold2 = grout_collect;}break;
                            case 3:{res_hold3 = grout_collect;}break;
                            case 4:{res_hold4 = grout_collect;}break;
                            case 5:{res_hold5 = grout_collect;}break;
                        }*/
                        obj_resource_manager.res1 += res_hold1;
                        obj_resource_manager.res2 += res_hold2;
                        obj_resource_manager.res3 += res_hold3;
                        obj_resource_manager.res4 += res_hold4;
                        obj_resource_manager.res5 += res_hold5;
                        res_hold1 = 0;
                        res_hold2 = 0;
                        res_hold3 = 0;
                        res_hold4 = 0;
                        res_hold5 = 0;
                    }
                    holding_resources = false;
                    grout_collect = 0;
                }
            }
        }    
    }
    else
    if holding_resources = false
    {
        if instance_exists(grout_target)
        {
            move_x = res_x;
            move_y = res_y;
            able_to_move = true;
            if distance_to_object(grout_target) &lt;= grout_target.area_size  // ACUTAL Gather Cycle *************** start
            {
                able_to_move = false;
                if can_gather = true
                {
                    able_to_move = false;
                    alarm[1] = gathercooldown;
                    can_gather = false;
                    holding_resources = true;
                    state = 3;
                    image_index = 0;
                    image_speed = 0.5;
                }            
                switch (grout_type) // to do with animations
                {
                    case 0:
                    {
                        if state = 3 &amp;&amp; image_index = gath_spr_length
                        {
                            state = 0;
                            image_speed = 0;
                        }
                        if state = 3 &amp;&amp; image_index = gath_spr_hit
                        {
                            grout_target.resource_amount -= gather_rate;
                            grout_collect += gather_rate;
                            if grout_target.resource_amount &lt;= 0
                            {
                                with(grout_target){instance_destroy();}
                            }
                        }
                    }
                    break;
                    case 1:
                    {
                        grout_target.resource_amount -= res_hold_lim;
                        grout_collect += res_hold_lim;
                        if grout_target.resource_amount &lt;= 0
                        {
                            with(grout_target){instance_destroy();}
                        }
                    }
                    break; // ACUTAL Gather Cycle *************** end
                }
            }
        }
        else
        {
            gathering = false;  //** not checked - possible problem area
            able_to_move = false;
        }
    }
        //else
        if instance_exists(grout_target) = false
        {
            temp = instance_nearest(res_x + random(4) - random(4), res_y + random(4) - random(4), grout_object)    
        
            if distance_to_object(temp) &lt;= 300
            {
                grout_type = temp.type;
                //grout_collect = temp.resource_num;
                switch(temp.resource_num)
                {
                    case 1:{grout_collect = res_hold1;}break;
                    case 2:{grout_collect = res_hold2;}break;
                    case 3:{grout_collect = res_hold3;}break;
                    case 4:{grout_collect = res_hold4;}break;
                    case 5:{grout_collect = res_hold5;}break;
                }
                grout_resnum = temp.resource_num;
                grout_target = temp;
                grout_object = temp.object_index;
                res_x = temp.x;
                res_y = temp.y;
                grout_deposit = instance_nearest(x,y,grout_peonhouse); //clostest peon building structure
                //enter gathering routine
                gathering = true;
            }
            else
            {
                //gathering = false;
                //able_to_move = false;
                if instance_exists(grout_deposit) //** not checked - possible problem area   |
                {                                 //                                        \/
                    move_x = grout_deposit.x
                    move_y = grout_deposit.y
                    able_to_move = true;
                    state = 5;
                    if distance_to_object(grout_deposit) &lt;= grout_deposit.area_size
                    {
                        {
                            /*switch(grout_resnum)
                            {
                                case 1:{res_hold1 = grout_collect;}break;
                                case 2:{res_hold2 = grout_collect;}break;
                                case 3:{res_hold3 = grout_collect;}break;
                                case 4:{res_hold4 = grout_collect;}break;
                                case 5:{res_hold5 = grout_collect;}break;
                            }*/
                            obj_resource_manager.res1 += res_hold1;
                            obj_resource_manager.res2 += res_hold2;
                            obj_resource_manager.res3 += res_hold3;
                            obj_resource_manager.res4 += res_hold4;
                            obj_resource_manager.res5 += res_hold5;
                            res_hold1 = 0;
                            res_hold2 = 0;
                            res_hold3 = 0;
                            res_hold4 = 0;
                            res_hold5 = 0;
                        }
                    holding_resources = false;
                    grout_collect = 0;
                    }
                }
            }
        }
    switch(grout_resnum)
    {
        case 1:{res_hold1 = grout_collect;}break;
        case 2:{res_hold2 = grout_collect;}break;
        case 3:{res_hold3 = grout_collect;}break;
        case 4:{res_hold4 = grout_collect;}break;
        case 5:{res_hold5 = grout_collect;}break;
    }
}
//Gathering - end

//Building - start
if iscratorer = true
{
    if build_ing = true
    {
        if instance_exists(build_target)
        {
            if build_target.is_built = false
            {
                if distance_to_object(build_target) &lt;= 2
                {
                    state = 6;
                    build_target.build_progress += build_power;
                }
                else
                {
                    state = 1;
                    mp_potential_step(buildn_x,buildn_y,unit_speed,false);
                }
            }
            else
            {
                build_ing = false;
            }
        }
        else
        {
            build_ing = false;
        }
    }
}
//Building - end

//Casting - start
if (cast = true)
{
    switch (cast_type)
    {
        case 0:
        {
            if (casting = false)
            {
                direction = point_direction(x, y,cast_targetx, cast_targety);
                alarm[3] = cast_time;
                casting = true;
                state = 7;
            }
        } break;
        case 1:
        {
            if (casting = false)
            {
                if ((distance_to_object(cast_target) &gt; cast_range) &amp;&amp; (distance_to_object(cast_target) != 1000000))
                {
                    mp_potential_step(cast_target.x, cast_target.y, unit_speed, false);
                    state = 1;
                }
                else
                {
                    if (!(cast_target==id))
                    {
                        direction = point_direction(x, y,cast_target.x, cast_target.y);
                    }
                    alarm[3] = cast_time;
                    casting = true;
                    state = 7;
                }
            }
        } break;
        case 2:
        {
            if (casting = false)
            {
                if (distance_to_point(cast_targetx, cast_targety) &gt; cast_range)
                {
                    mp_potential_step(cast_targetx, cast_targety, unit_speed, false);
                    state = 1;
                }
                else
                {
                    direction = point_direction(x, y,cast_targetx, cast_targety);
                    alarm[3] = cast_time;
                    casting = true;
                    state = 7;
                }
            }
        } break;
        case 3:
        {
            if (casting = false)
            {
                alarm[3] = cast_time;
                casting = true;
                state = 7;
            }
        } break;
    }
    
    if (casting = true)
    {
        state = 7;
        image_speed = 0.5;
    }
}
//Casting - end

//Unit bumping (so they dont pile up on each other) - start
/* THIS WAS CAUSING WAY TOO MUCH SLOWDOWN, SO I PUT IT IN ALARM 4!!!!
if (_prevx = x &amp;&amp; _prevy = y)
{
    instance_deactivate_object(self);
    ally_nrst = instance_nearest(x, y+y_offset, all);
    instance_activate_object(self);
    if (instance_exists(ally_nrst))
    {
        if (distance_to_point(ally_nrst.x, ally_nrst.y)&lt;=foot_radius)
        {
            anglay = point_direction(ally_nrst.x, ally_nrst.y, x, y+y_offset); // this is in degress
            anglay_r = (anglay*pi)/180; //convert to radians
            goto_x = x + push_rate*(cos(anglay_r));
            goto_y = y + push_rate*(-sin(anglay_r));
            temp_len_x = foot_radius*(cos(pi/2));
            temp_len_y = foot_radius*(-sin(pi/2))
            if ((place_free(goto_x+temp_len_x, goto_y+temp_len_y))&amp;&amp;
                (place_free(goto_x+temp_len_x, goto_y-temp_len_y))&amp;&amp;
                (place_free(goto_x-temp_len_x, goto_y+temp_len_y))&amp;&amp;
                (place_free(goto_x-temp_len_x, goto_y-temp_len_y)))
            {
                x = goto_x;
                y = goto_y;
            }
        }
    }
}
_prevx = x;
_prevy = y;
*/
//Unit bumping (so they dont pile up on each other) - start




//Check if stunned or similar - end
}




//Button Cooldowns ticks - start
for (i=0;i&lt;18;i+=1)
{
    if (hud_button_cooldown_index[i]&gt;0)
    {
        hud_button_cooldown_index[i] -= 1;
    }
}
//Button Cooldown ticks - end

//HUD - start
if selected = true &amp;&amp; global.number_of_selected = 1
{
    obj_HUD.target = self.id;
}
//HUD - end

//temp
if (able_to_move = true){image_speed=0.5;}
if (able_to_move = false &amp;&amp; state = 0){image_speed=0;}
if (able_to_move = false &amp;&amp; state = 2){image_speed=0.5;}
if (able_to_move = false &amp;&amp; state = 1){image_speed=0.5;}
if (able_to_move = false &amp;&amp; state = 3){image_speed=0.5;}
if (stunned==true){state=0;image_speed=0.5;}
if (scilenced==true){image_speed=0.5;}
//temp</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if mouse is not in hud - start
if ((mouse_y - view_yview[0]) &lt;= obj_HUD.border) &amp;&amp; (obj_minimap.active==false)
{



//Selection - start
if obj_selector.draw = true &amp;&amp; selected = false
{
    if x&gt;obj_selector.mousex &amp;&amp; x&lt;mouse_x &amp;&amp; y&gt;obj_selector.mousey &amp;&amp; y&lt;mouse_y { selected = true; global.number_of_selected += 1; }
    if x&lt;obj_selector.mousex &amp;&amp; x&gt;mouse_x &amp;&amp; y&gt;obj_selector.mousey &amp;&amp; y&lt;mouse_y { selected = true; global.number_of_selected += 1; }
    if x&gt;obj_selector.mousex &amp;&amp; x&lt;mouse_x &amp;&amp; y&lt;obj_selector.mousey &amp;&amp; y&gt;mouse_y { selected = true; global.number_of_selected += 1; }
    if x&lt;obj_selector.mousex &amp;&amp; x&gt;mouse_x &amp;&amp; y&lt;obj_selector.mousey &amp;&amp; y&gt;mouse_y { selected = true; global.number_of_selected += 1; }
}
//Selection - end



}
// mouse not in hud - end

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="54">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if mouse is not in hud - start
if ((mouse_y - view_yview[0]) &lt;= obj_HUD.border)
{
//if casting is false - start
if cast = false
{


//Stop the bumping fix - start
been_bumped = false;
alarm[5] = 0;
//Stop the bumping fix - end

//Moving - start
if selected = true
{
    if attack_mode = true || attack_target != 99 //cancels and attacking
    {
        attack_target = 99;
        attack_mode = false;
    }
    if gathering = true
    {
        gathering = false;
    }
    if build_ing = true
    {
        build_ing = false;
    }
    //NEW ADVANCED MOVEMENT
    if global.number_of_selected &gt;= 2
    {
    row = obj_selector.row;
    col = obj_selector.column;
    extra = obj_selector.extra;
    xadjust = (col * 20)/2;
    yadjust = (row * 20)/2;
    if obj_selector.refreshed = false{for (i=1;i&lt;(col+1);i+=1){for (z=1;z&lt;(row+1);z+=1){obj_selector.spotav[i,z]=false;obj_selector.refreshed = true;obj_selector.alarm[2]=1}}}

    
    fin = false;
    for (i=1;i&lt;col;i+=1)
    {
        for (z=1;z&lt;row;z+=1)
        {
            if obj_selector.spotav[i,z] = false
            {
                move_x = (mouse_x-xadjust+obj_selector.spotx[i,z]);
                move_y = (mouse_y-yadjust+obj_selector.spoty[i,z]);
                obj_selector.spotav[i,z] = true;
                fin = true;
                break;
            }
           if (fin=true){break;}
        }
       if (fin=true){break;} 
    }
    if fin=false
    {
        for (j=1;j&lt;extra;j+=1)
        {
            if obj_selector.spotav[(col+1),j] = false
            {
                move_x = (mouse_x-xadjust+obj_selector.spotx[(col+1),j]);
                move_y = (mouse_y-yadjust+obj_selector.spoty[(col+1),j]);
                obj_selector.spotav[(col+1),j] = true;
                fin = true;
                break;
            }
        }
    }
    }
    else
    {
    move_x = mouse_x;
    move_y = mouse_y;
    }
    //
    able_to_move = true;
}
//Moving - end

//Attacking - start
if selected = true
{
    if instance_place(mouse_x,mouse_y,attackable_units)
    {
        if attack_mode = true || attack_target != 99 
        {
            attack_target = 99;
            attack_mode = false;
        }
        //test to see if this fixes bug
        if able_to_move = true
        {
            able_to_move = false;
            state = 0;
        }
        //test to see if this fixes bug
        //new - might cause bugs
        if gathering = true
        {
            gathering = false;
        }
        if build_ing = true
        {
            build_ing = false;
        }
        //new - might cause bugs
        selected_enemy = instance_place(mouse_x,mouse_y,attackable_units);
        attack_target = selected_enemy;
        attack_mode = true;
        able_to_move = false;
        move_x = x;
        move_y = y;
    }
}
//Attacking - end

//Peoning - start
if selected = true &amp;&amp; ispeon = true
{
    if instance_place(mouse_x,mouse_y,obj_resource_parent)
    {
        //new - could cause bugs - just cancels attacking and building
        if attack_mode = true || attack_target != 99 //cancels and attacking
        {
            attack_target = 99;
            attack_mode = false;
        }
        if build_ing = true
        {
            build_ing = false;
        }
        //new - could cause bugs - just cancels attacking and building
        //gather information for gathering routine
        tmp_res = instance_place(mouse_x,mouse_y,obj_resource_parent);
        grout_type = tmp_res.type;
        //grout_collect = tmp_res.resource_num;
        switch(tmp_res.resource_num)
        {
            case 1:{grout_collect = res_hold1;}break;
            case 2:{grout_collect = res_hold2;}break;
            case 3:{grout_collect = res_hold3;}break;
            case 4:{grout_collect = res_hold4;}break;
            case 5:{grout_collect = res_hold5;}break;
        }
        grout_resnum = tmp_res.resource_num;
        grout_target = tmp_res;
        grout_object = tmp_res.object_index;
        res_x = tmp_res.x;
        res_y = tmp_res.y;
        grout_deposit = instance_nearest(x,y,peonhouse/*temp*/); //clostest peon building structure
        //enter gathering routine
        gathering = true;
    }
}
//Peoning - end

//Building - start
if selected = true &amp;&amp; iscratorer = true
{
    if instance_place(mouse_x,mouse_y,obj_building_parent)
    {
        build_target = instance_place(mouse_x,mouse_y,obj_building_parent);
        if build_target.is_built = false &amp;&amp; build_target.is_placed = true
        {
            //new - could cause bugs - just cancels attacking and gathering
            if able_to_move = true
            {
                able_to_move = false;
            }
            if attack_mode = true || attack_target != 99 //cancels and attacking
            {
                attack_target = 99;
                attack_mode = false;
            }
            if gathering = true
            {
                gathering = false;
            }
            //new - could cause bugs - just cancels attacking and gathering
            buildn_x = build_target.x;
            buildn_y = build_target.y;
            build_ing = true;
        }
    }
}
//Building - end


}
// if casting is false - end
}
// mouse not in hud - end</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if mouse is not in hud - start
if ((mouse_y - view_yview[0]) &lt;= obj_HUD.border) &amp;&amp; (obj_minimap.active==false)
{



//Selection - start
if selected = true &amp;&amp; keyboard_check(vk_shift) = false &amp;&amp; distance_to_point(mouse_x,mouse_y) &gt;= 1
{
    selected = false;
    global.number_of_selected -= 1;
}
//Selection - end



}
//if mouse not in hud - end</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if mouse is not in hud - start
if ((mouse_y - view_yview[0]) &lt;= obj_HUD.border)
{



// Selection - start
if selected = false
{
    selected = true;
    global.number_of_selected += 1;
}
// Selection - end



}
// mouse not in hud - end</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Selection - start
if selected = true
{
    draw_set_alpha(1);
    draw_set_color(c_lime);
    draw_ellipse(x+selectcx1,y+selectcy1,x+selectcx2,y+selectcy2,true);
}
//Selection - end

//Unit Animations - start
//- this is the old version
/*
switch (state)
{
    case 0: if direction &gt; 247 &amp;&amp; direction &lt; 292 {draw_sprite(spr_man_down,-1,x,y);}
            if direction &gt; 292 &amp;&amp; direction &lt; 332 {draw_sprite(spr_man_downright,-1,x,y);}
            if (direction &gt; 332 &amp;&amp; direction &lt; 360) or (direction &gt; 0 &amp;&amp; direction &lt; 22) {draw_sprite(spr_man_right,-1,x,y);}
            if direction &gt; 22 &amp;&amp; direction &lt; 67 {draw_sprite(spr_man_upright,-1,x,y);}
            if direction &gt; 67 &amp;&amp; direction &lt; 112 {draw_sprite(spr_man_up,-1,x,y);}
            if direction &gt; 112 &amp;&amp; direction &lt; 157 {draw_sprite(spr_man_upleft,-1,x,y);}
            if direction &gt; 157 &amp;&amp; direction &lt; 202 {draw_sprite(spr_man_left,-1,x,y);}
            if direction &gt; 202 &amp;&amp; direction &lt; 247 {draw_sprite(spr_man_downleft,-1,x,y);}
    break;
    case 1: if direction &gt; 247 &amp;&amp; direction &lt; 292 {draw_sprite(spr_man_down_walk,-1,x,y);}
            if direction &gt; 292 &amp;&amp; direction &lt; 332 {draw_sprite(spr_man_downright_walk,-1,x,y);}
            if (direction &gt; 332 &amp;&amp; direction &lt; 360) or (direction &gt; 0 &amp;&amp; direction &lt; 22) {draw_sprite(spr_man_right_walk,-1,x,y);}
            if direction &gt; 22 &amp;&amp; direction &lt; 67 {draw_sprite(spr_man_upright_walk,-1,x,y);}
            if direction &gt; 67 &amp;&amp; direction &lt; 112 {draw_sprite(spr_man_up_walk,-1,x,y);}
            if direction &gt; 112 &amp;&amp; direction &lt; 157 {draw_sprite(spr_man_upleft_walk,-1,x,y);}
            if direction &gt; 157 &amp;&amp; direction &lt; 202 {draw_sprite(spr_man_left_walk,-1,x,y);}
            if direction &gt; 202 &amp;&amp; direction &lt; 247 {draw_sprite(spr_man_downleft_walk,-1,x,y);}
    break;
    case 2: if direction &gt; 247 &amp;&amp; direction &lt; 292 {draw_sprite(spr_man_down_attack,-1,x,y);}
            if direction &gt; 292 &amp;&amp; direction &lt; 332 {draw_sprite(spr_man_downright_attack,-1,x,y);}
            if (direction &gt; 332 &amp;&amp; direction &lt; 360) or (direction &gt; 0 &amp;&amp; direction &lt; 22) {draw_sprite(spr_man_right_attack,-1,x,y);}
            if direction &gt; 22 &amp;&amp; direction &lt; 67 {draw_sprite(spr_man_upright_attack,-1,x,y);}
            if direction &gt; 67 &amp;&amp; direction &lt; 112 {draw_sprite(spr_man_up_attack,-1,x,y);}
            if direction &gt; 112 &amp;&amp; direction &lt; 157 {draw_sprite(spr_man_upleft_attack,-1,x,y);}
            if direction &gt; 157 &amp;&amp; direction &lt; 202 {draw_sprite(spr_man_left_attack_attack,-1,x,y);}
            if direction &gt; 202 &amp;&amp; direction &lt; 247 {draw_sprite(spr_man_downleft_attack,-1,x,y);}
    break;
};
*/
if direction &gt; 247 &amp;&amp; direction &lt; 292 {draw_sprite(state_anim[state,0],-1,x,y);}
if direction &gt; 292 &amp;&amp; direction &lt; 332 {draw_sprite(state_anim[state,1],-1,x,y);}
if (direction &gt; 332 &amp;&amp; direction &lt; 360) or (direction &gt;= 0 &amp;&amp; direction &lt; 22) {draw_sprite(state_anim[state,2],-1,x,y);}
if direction &gt; 22 &amp;&amp; direction &lt; 67 {draw_sprite(state_anim[state,3],-1,x,y);}
if direction &gt; 67 &amp;&amp; direction &lt; 112 {draw_sprite(state_anim[state,4],-1,x,y);}
if direction &gt; 112 &amp;&amp; direction &lt; 157 {draw_sprite(state_anim[state,5],-1,x,y);}
if direction &gt; 157 &amp;&amp; direction &lt; 202 {draw_sprite(state_anim[state,6],-1,x,y);}
if direction &gt; 202 &amp;&amp; direction &lt; 247 {draw_sprite(state_anim[state,7],-1,x,y);}

//Unit animations - end

//Health Bar - start
if ((selected==true)||(distance_to_point(mouse_x, mouse_y)&lt;=0))
{
    _len = (healthbar_length*(unit_hp/unit_hp_max)); 
    draw_set_alpha(1);
    draw_set_color(healthbar_bg_col);
    draw_rectangle(x+healthbar_x,y+healthbar_y,x+healthbar_x+healthbar_length,y+healthbar_y+healthbar_height,false);
    draw_set_color(healthbar_fg_col);
    draw_rectangle(x+healthbar_x+1,y+healthbar_y+1,x+healthbar_x+_len-1,y+healthbar_y+healthbar_height-1,false);
}
//Health Bar - end

//Ailment animations - start
if (ailment_count&gt;0)
{
    startx_draw = -((ailment_count*((ailment_size*(ailment_count-1))+(ailment_gap*(ailment_count-1))))/4)
    for (i=0;i&lt;ailment_count;i+=1)
    {
        draw_sprite(ailment_list[i], -1, x+startx_draw+(i*(ailment_size+ailment_gap)), y+ailment_pos);
    }
}
//Ailment animations - end

//temp - start
//temp - if(able_to_move){draw_line(x,y,move_x,move_y);} //use this for debugging
//if direction &gt; 247 &amp;&amp; direction &lt; 292 {draw_sprite(spr_man_down_walk,-1,x,y);}
//if direction &gt; 292 &amp;&amp; direction &lt; 332 {draw_sprite(spr_man_downright_walk,-1,x,y);}
//if (direction &gt; 332 &amp;&amp; direction &lt; 360) or (direction &gt; 0 &amp;&amp; direction &lt; 22) {draw_sprite(spr_man_right_walk,-1,x,y);}
//if direction &gt; 22 &amp;&amp; direction &lt; 67 {draw_sprite(spr_man_upright_walk,-1,x,y);}
//if direction &gt; 67 &amp;&amp; direction &lt; 112 {draw_sprite(spr_man_up_walk,-1,x,y);}
//if direction &gt; 112 &amp;&amp; direction &lt; 157 {draw_sprite(spr_man_upleft_walk,-1,x,y);}
//if direction &gt; 157 &amp;&amp; direction &lt; 202 {draw_sprite(spr_man_left_walk,-1,x,y);}
//if direction &gt; 202 &amp;&amp; direction &lt; 247 {draw_sprite(spr_man_downleft_walk,-1,x,y);}
//temp - end</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
