<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_man_mask</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_unit_parent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/* - Setup - */
/*var*/ selected = false; // generally dont touch any of the following
/*var*/ //selectcx1 = -14;
/*var*/ //selectcx2 = 14;
/*var*/ //selectcy1 = 9;
/*var*/ //selectcy2 = 21;
/*var*/ able_to_move = false;
/*var*/ move_x = 0;
/*var*/ move_y = 0;
/*var*/ direction = 270;
/*var*/ image_speed = 0.5;
/*var*/ state = 0 /* 0 is standing, 1 is walking, 2 is attacking, 3 is gathering (peon only), 4 is special, 5 is walking while holding resources, 6 is building, 7 is for casting*/
/*var*/ //ally_units = obj_unit_parent;
/*var*/ //unit_pic = spr_man_pic; // the pic for the unit on the hud
/*var*/ 
/* - Setup version 2- */
/*var*/ //y_offset = 7; // this offest makes it so the centre of the unit is somewhere near its feet, to give the isometric feel
/*var*/ //foot_radius = 10; //the radius of the circle under the units feet, which is used for pushing against other units
/*var*/ _prevx = 0; // these two variables are used for telling if the unit is standing still NOTE!! i just relised that gamemaker has built in varibales that do EXACTLY this, so use them instead if you want
/*var*/ _prevy = 0;
/*var*/ //push_rate = 2; // this is the speed at which the units push against eachother, when they pile up on top of each other
/*var*/ //alarm[4] = 5; // This DOESNT have to be alarm 4, but make sure you fix the other vaiable to make it work for a different alram
/*var*/ //bump_delay = 30; //how long after being INITIALLY bumped, to walk back to original position
/*var*/ been_bumped = false;
/*var*/ 
/* - Setup version 3: Ailments- */
/*var*/ //ailment_pos = -20 // where the icons ill show up relatice to the centre of the unit
/*var*/ //ailment_size = 16; //the general size of the icons
/*var*/ //ailment_gap = 3; //the gap between the ailments, if there ismore than one
/*var*/ ailment_count = 0; // the number of ailments that the unit is currently suffering from
/*var*/ ailment_list[0] = spr_temp; //this holds the list of sprites of ailmets that the unit is duffering from. Yeah, don't touch this one
/*var*/ 
/*var*/ stunned = false; //stun
/*var*/ stun_counter = 0; //how much longer this guy willbe stunned for
/*var*/ stun_spr = spr_ailment_stun; //icon of the stun
/*var*/ 
/*var*/ scilenced = false; //scilence
/*var*/ scilence_counter = 0; //how much longer this guy will be scilenced for
/*var*/ scilence_spr = spr_ailment_scilence; //icon of the scilence
/*var*/ 
/*var*/ //You can add more of your own here
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/* - Stats - */
/*var*/ //unit_speed = 3;
/*var*/ //unit_area = 30; 
/*var*/ //unit_hp = 20;
/*var*/ //unit_hp_max = 20;
/*var*/ //unit_damage = 3;
/*var*/ //unit_damage_range = 1;
/*var*/ //unit_name = "Villi"
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/* - Graphics - */
/*var*/ g_name = "spr_man_"; // dun use this bruddah
/*var*/ stand_anim = "";
/*var*/ walk_anim = "_walk";
/*var*/ attack_anim = "_attack"
/*var*/ //gather_anim =
/*var*/ 
/* initializing sprites */
/*var*/ //state_anim[0,0] = spr_man_down;
/*var*/ //state_anim[0,1] = spr_man_downright;
/*var*/ //state_anim[0,2] = spr_man_right;
/*var*/ //state_anim[0,3] = spr_man_upright;
/*var*/ //state_anim[0,4] = spr_man_up;
/*var*/ //state_anim[0,5] = spr_man_upleft;
/*var*/ //state_anim[0,6] = spr_man_left;
/*var*/ //state_anim[0,7] = spr_man_downleft;
/*var*/ //state_anim[1,0] = spr_man_down_walk; // for walking
/*var*/ //state_anim[1,1] = spr_man_downright_walk;
/*var*/ //state_anim[1,2] = spr_man_right_walk;
/*var*/ //state_anim[1,3] = spr_man_upright_walk;
/*var*/ //state_anim[1,4] = spr_man_up_walk;
/*var*/ //state_anim[1,5] = spr_man_upleft_walk;
/*var*/ //state_anim[1,6] = spr_man_left_walk;
/*var*/ //state_anim[1,7] = spr_man_downleft_walk;
/*var*/ //state_anim[2,0] = spr_man_down_attack; //for attacking
/*var*/ //state_anim[2,1] = spr_man_downright_attack;
/*var*/ //state_anim[2,2] = spr_man_right_attack;
/*var*/ //state_anim[2,3] = spr_man_upright_attack;
/*var*/ //state_anim[2,4] = spr_man_up_attack;
/*var*/ //state_anim[2,5] = spr_man_upleft_attack;
/*var*/ //state_anim[2,6] = spr_man_left_attack;
/*var*/ //state_anim[2,7] = spr_man_downleft_attack;
/*var*/ //state_anim[3,0] = spr_man_down_attack; // the following should be for the gathering animation
/*var*/ //state_anim[3,1] = spr_man_downright_attack;
/*var*/ //state_anim[3,2] = spr_man_right_attack;
/*var*/ //state_anim[3,3] = spr_man_upright_attack;
/*var*/ //state_anim[3,4] = spr_man_up_attack;
/*var*/ //state_anim[3,5] = spr_man_upleft_attack;
/*var*/ //state_anim[3,6] = spr_man_left_attack;
/*var*/ //state_anim[3,7] = spr_man_downleft_attack;

/*var*/ //state_anim[5,0] = spr_man_down_walk; // for walking while holding resources
/*var*/ //state_anim[5,1] = spr_man_downright_walk;
/*var*/ //state_anim[5,2] = spr_man_right_walk;
/*var*/ //state_anim[5,3] = spr_man_upright_walk;
/*var*/ //state_anim[5,4] = spr_man_up_walk;
/*var*/ //state_anim[5,5] = spr_man_upleft_walk;
/*var*/ //state_anim[5,6] = spr_man_left_walk;
/*var*/ //state_anim[5,7] = spr_man_downleft_walk;

/*var*/ //state_anim[6,0] = spr_man_down_attack; // for building
/*var*/ //state_anim[6,1] = spr_man_downright_attack;
/*var*/ //state_anim[6,2] = spr_man_right_attack;
/*var*/ //state_anim[6,3] = spr_man_upright_attack;
/*var*/ //state_anim[6,4] = spr_man_up_attack;
/*var*/ //state_anim[6,5] = spr_man_upleft_attack;
/*var*/ //state_anim[6,6] = spr_man_left_attack;
/*var*/ //state_anim[6,7] = spr_man_downleft_attack;

/*var*/ //state_anim[7,0] = spr_man_cast_down; // for casting animation
/*var*/ //state_anim[7,1] = spr_man_cast_downright;
/*var*/ //state_anim[7,2] = spr_man_cast_right;
/*var*/ //state_anim[7,3] = spr_man_cast_upright;
/*var*/ //state_anim[7,4] = spr_man_cast_up;
/*var*/ //state_anim[7,5] = spr_man_cast_upleft;
/*var*/ //state_anim[7,6] = spr_man_cast_left;
/*var*/ //state_anim[7,7] = spr_man_cast_downleft;
/* - Peon Attributes - */
/*var*/ //ispeon = true; //if able to gather resources
/*var*/ gathering = false; //if is in gathering routine
/*var*/ can_gather = true;
/*var*/ //gather_rate = 1; // how much of the resource the unit gathers per hit
/*var*/ //gathercooldown = 17; //cooldown of gather attack
/*var*/ holding_resources = false; // if is holding resources
/*var*/ res_hold1 = 0; //amount of resource1 it is currently holding
/*var*/ res_hold2 = 0; //amount of resource2 it is currently holding
/*var*/ res_hold3 = 0; //amount of resource3 it is currently holding
/*var*/ res_hold4 = 0; //amount of resource4 it is currently holding
/*var*/ res_hold5 = 0; //amount of resource5 it is currently holding
/*var*/ res_hold_lim = 10; //the max amount of resources it can carry at once
/*var*/ res_x = 99;
/*var*/ res_y = 99;
/*var*/ grout_type = 99; //collection type (0 = mining, 1 = collecting)
/*var*/ grout_collect = 99; //resource variable eg. res_hold2 (NO!)
/*var*/ grout_resnum = 99; // the one above
/*var*/ grout_target = 99; //resource object
/*var*/ grout_deposit = 99; //house to dump all the resources
/*var*/ grout_object = 99; // object of target
/*var*/ //grout_peonhouse = peonhouse; //the building that the unit deposits resources to
/*var*/ //gath_spr_length = 2; // how long or how many diff sprites your animation has
/*var*/ //gath_spr_hit = 1; //the image num where the unit would of hit the target
/*var*/ collecting = false; // tells us whether the unit is collecting or storing the resources
/*var*/ 
/*var*/ 
/*var*/ 
/* - Building - */
/*var*/ //iscratorer = true; //if it can build buildings
/*var*/ buildn_x = 0;
/*var*/ buildn_y = 0;
/*var*/ build_power = 2; // how fast this guy builds
/*var*/ build_target = 99; //the builing that is targeted to built
/*var*/ build_ing = false; //if the unit is in the process of building or not
/*var*/ build_ables = global.obj_building_type[0,global.PlayerId]; // objects that can be built by this unit
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/* - Atakking - */
/*var*/ attacking = false;
/*var*/ //attack_type = 0; //0 = close, 1 = long ranged, 2 = other
/*var*/ //attack_range = 2; // was 2 please change back  - FOR BOTH RANGED AND MELEE
/*var*/ nearest_enemy = 99;
/*var*/ attack_target = 99;
/*var*/ //autoattack_range = 200; // -- please change back to 250
/*var*/ attack_mode = false;
/*var*/ tmp_enmy = 99;
/*var*/ //attack_cooldown = 20; // -- was orriginally 10, but a bit too fast. 20 seem decent
/*var*/ can_attack = true;
/*var*/ //atk_spr_length = 2; // how long or how many diff sprites you attack animation has - MELEE ONLY
/*var*/ //atk_spr_hit = 1; // for attempt 2, the image num where the unit would of hit the target - MELEE ONLY
/*var*/ //attack_range_obj = obj_projectile_template; // the object that is your ranged projectile - RANGED ONLY
/*var*/ attack_range_range = 160; // range of your ranged attack OI!! plox dont use this - use attack_range - RANGED ONLY
/*var*/ //attack_range_speed = 9; // speed of the projectile - RANGED ONLY
/*var*/ //attack_range_AOE = 1; // area of effect of projectile - RANGED ONLY
/*var*/ //attackable_units = obj_unit_enemy_parent; // units that are enemys - the ones that are auto attacked
/*var*/ //atk_spr_rng_hit = 1; // the image num where the unit would of shot the projectile - RANGED ONLY
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/*var*/ 
/* - Spell Casting - */
/*var*/ cast_range = 99;  //generally do NOT touch this stuff. PLIAS!!
/*var*/ cast_cooldown = 99;
/*var*/ cast_type = 99;
/*var*/ cast_damage = 99;
/*var*/ cast_target_obj = 99;
/*var*/ cast_targetx = 99;
/*var*/ cast_targety = 99;
/*var*/ cast_targettype = 99;
/*var*/ cast_object = 99;
/*var*/ cast_cost = 99;
/*var*/ cast_spellname = 99;
/*var*/ cast_time = 99;
/*var*/ cast_proj_speed = 99;
/*var*/ cast_proj_aoe = 99;
/*var*/ cast = false; // this is the flag that says whether or not the unit has been ordered to cast the spell
/*var*/ casting = false; //this is whether the ACTUAL casting is taking place
/*var*/ cast_button_index = 99;
/*var*/ cast_code = 99;
/*var*/ 
/* - HUD - */
/*var*/ //hud_gen_s1 = obj_button_test_message;
/*var*/ //hud_gen_s2 = obj_button_template;
/*var*/ //hud_gen_s3 = obj_button_template;
/*var*/ //hud_gen_s4 = obj_button_template;
/*var*/ //hud_gen_s5 = obj_button_template;
/*var*/ //hud_gen_s6 = obj_button_template;
/*var*/ //hud_gen_s7 = obj_button_template;
/*var*/ //hud_gen_s8 = obj_button_template;
/*var*/ //hud_gen_s9 = obj_button_template;
/*var*/ //hud_gen_s10 = obj_button_template;
/*var*/ //hud_gen_s11 = obj_button_template;
/*var*/ //hud_gen_s12 = obj_button_template;
/*var*/ //hud_gen_s13 = obj_button_template;
/*var*/ //hud_gen_s14 = obj_button_spell_scilence;
/*var*/ //hud_gen_s15 = obj_button_spell_cocktail;
/*var*/ //hud_gen_s16 = obj_button_spell_clight;
/*var*/ //hud_gen_s17 = obj_button_heal;
/*var*/ //hud_gen_s18 = obj_button_spell1_template;
/*var*/ //hud_build_s1 = 99;
/*var*/ //hud_build_s2 = 99;
/*var*/ //hud_build_s3 = 99;
/*var*/ //hud_build_s4 = 99;
/*var*/ //hud_build_s5 = 99;
/*var*/ //hud_build_s6 = 99;
/*var*/ //hud_build_s7 = 99;
/*var*/ //hud_build_s8 = 99;
/*var*/ //hud_build_s9 = 99;
/*var*/ //hud_build_s10 = 99;
/*var*/ //hud_build_s11 = 99;
/*var*/ //hud_build_s12 = 99;
/*var*/ //hud_build_s13 = 99;
/*var*/ //hud_build_s14 = 99;
/*var*/ //hud_build_s15 = 99;
/*var*/ //hud_build_s16 = 99;
/*var*/ //hud_build_s17 = 99;
/*var*/ //hud_build_s18 = 99;
/*var*/ 
/*var*/ 
/* - for HUD - */
/* - for Health Bar - */
/*var*/ //healthbar_x = -14;
/*var*/ //healthbar_y = -26;
/*var*/ //healthbar_length = 28;
/*var*/ //healthbar_height = 4;
/*var*/ //healthbar_fg_col = c_lime;
/*var*/ //healthbar_bg_col = c_black;
/*var*/ 
/* - For Spell Cooldowns - */
for (i=0;i&lt;18;i+=1) //initialise cooldowns for buttons
{
    hud_button_cooldown_index[i] = 0;
}
/*var*/ is_is_building = false;
/* - Misc - */
/*var*/ stringx = "";
/* -  - */

/* - Network Code - */
sendRate1 = 1; //original value was 5
send1 = 0;
sendRate2 = 20;
send2 = 2;

prev_state = 0;

ownerId = 0; // id of the player that owns this unit
netId = 0; // id of unit, consistent with other clients


mypath=path_add(); //This is an empty path. We will use it from now on for all movement...
alarm[6]=0;
var dx,dy,foundpoint;

//building_x = x
//building_y = y
secondrun = 0


path = as_path_create(obj_map.map,x div 64,y div 32,x div 64, y div 32,1,2,-1) 

cliff_sight = false
/*
else { 

map = as_map_create(room_width/64, room_height/32, 1);
path = as_path_create(id.map,x div 64,y div 32,x div 64, y div 32,1,2,-1) ;
as_map_destroy(id.map);
}

*/

unit_cliff_id = noone // Fixed bug that deletes all trees
cliff_yet = 0

//Determines allegiance of unit: Different for each multiplayer person | Check CONSTANTS for values
//team = OWNER;
alarm[2] = 5

hostile_units[0] = "";
hostile_units_num = 0;

col_width = obj_map.map_col_width
row_height = obj_map.map_row_height

just_created = true



sprite_bbox_left = x - sprite_width/2
sprite_bbox_right = x + sprite_width/2
sprite_bbox_top = y - sprite_height/2
sprite_bbox_bottom = y + sprite_height/2

collide_building = 0;
toggle_resource = false
switch_to_resource = false
collide_gathering = 0

//if (global.PlayerId == ownerId) {
    ghost_ID = instance_create(x,y,obj_ally);
    ghost_ID.unit_ghost_of = id;
//}

dir = 0

hp_cooldown = 20

collide = 0
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="6">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
Must be set to 1 (alarm[6]=1) WHENEVER move_x and move_y are edited!!!

This alarm translates move_x and move_y into the pathfinding grid!
*/

//    dx=floor(move_x/64)*64+32;
    dx=floor(move_x/32)*32+16;
    dy=floor(move_y/32)*32+16;
    
//    cx=floor(x/64)*64+32;
    cx=floor(x/32)*32+16;
    cy=floor(y/32)*32+16;
    
as_path_destroy(path);

currenttile = as_map_getcell(obj_map.map,x/col_width,y/row_height)    
// align to "grid" so we don't get stuck in a wall
if currenttile &lt; 0 {move_snap(col_width,row_height)}


if as_map_getcell(obj_map.map,move_x/col_width,move_y/row_height) = -1 //This is checking to see if it is a blocked tile
{
    foundpoint=0
    k=1
    var tempx,tempy;
    while foundpoint==0 {   //Sentinel loop to keep testing coordinates around until a path is found
        tempx=move_x+(col_width*k);
//            tempx=dx+(64*k);
        tempy=move_y+(row_height*k);    
        if as_map_getcell(obj_map.map,tempx/col_width,tempy/row_height) {
            foundpoint=1;
            move_x=tempx;
            move_y=tempy;
        }
        else if k &gt; 50 {    //Failsafe in case a path canNOT be found
            foundpoint=1;
            dx=x;
            dy=y;
        }
        else {
//          tempx=dx-(64*k);
            tempx=move_x-(col_width*k);                
            tempy=move_y-(row_height*k);
            if as_map_getcell(obj_map.map,tempx/col_width,tempy/row_height) {
                  foundpoint=1;
                  move_x=tempx;
                  move_y=tempy;
            }
        }
        k=k+1;
    }
    /*
    mp_grid_path(global.mpgrid,mypath,x,y,dx,dy,true); //This now re_creates the path with the "good" coords...
    path_start(mypath,unit_speed,0,1); //This starts the object moving on the path...
    move_x=dx;
    move_y=dy; */
}
    
path = as_path_create(obj_map.map,x div col_width,y div row_height,move_x div col_width, move_y div row_height,1,2,-1)
    
    
    
    

    /*
    if !mp_grid_path(global.mpgrid,mypath,x,y,dx,dy,true) //This is debugging to make sure a path exists...
    {
        foundpoint=0
        k=1
        var tempx,tempy;
        while foundpoint==0 {   //Sentinel loop to keep testing coordinates around until a path is found
            tempx=dx+(32*k);
//            tempx=dx+(64*k);
            tempy=dy+(32*k);    
            if mp_grid_path(global.mpgrid,mypath,x,y,tempx,tempy,true) {
                foundpoint=1;
                dx=tempx;
                dy=tempy;
            }
            else if k &gt; 50 {    //Failsafe in case a path canNOT be found
                foundpoint=1;
                dx=x;
                dy=y;
            }
            else {
//                tempx=dx-(64*k);
                tempx=dx-(32*k);                
                tempy=dy-(32*k);
                if mp_grid_path(global.mpgrid,mypath,x,y,tempx,tempy,true) {
                      foundpoint=1;
                      dx=tempx;
                      dy=tempy;
                }
            }
            k=k+1;
        }
        
        mp_grid_path(global.mpgrid,mypath,x,y,dx,dy,true); //This now re_creates the path with the "good" coords...
        path_start(mypath,unit_speed,0,1); //This starts the object moving on the path...
        move_x=dx;
        move_y=dy;
    }
    else
    {
        mp_grid_path(global.mpgrid,mypath,x,y,dx,dy,true); //This now creates the path...
        path_start(mypath,unit_speed,0,1); //This starts the object moving on the path...
    }
    
    */
//alarm[6]=10;        //Alarm runs every 10 tics instead of 1 tic to save memory. Path is still conserved!!

        /*var j,k,tempx,tempy,foundypoint;
                
        j=1;
        k=1; 
        foundpoint=0; 
                
        while (foundpoint=0) {
                    tempx=x2+(64*k);
                    tempy=y2+(32*k);
                    if !collision_line(x1,y1,tempx,tempy,obj_building_template_multi,false,true) {
                        foundpoint=1;
                        colpointonetest=collision_line(x1,y1,tempx,tempy,obj_building_template_multi,false,true)
                    }
                    else {
                        tempx=x2-(64*k);
                        tempy=y2-(32*k);
                        if !collision_line(x1,y1,tempx,tempy,obj_building_template_multi,false,true) {
                            foundpoint=1;
                            colpointtwotest=collision_line(x1,y1,tempx,tempy,obj_building_template_multi,false,true)
                        }
                    }
                    k=k+1;
                }
        */
        
//obj_new_fog_of_war.array_cliff_units[obj_new_fog_of_war.acu + 1] = id
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if (true) { exit; } //stop Alarm[5]
if (global.PlayerId != ownerId) { exit; } //check that player owns unit
//if mouse is not in hud - start
if ((mouse_y - view_yview[0]) &lt;= obj_HUD.border || global.mapMovement == 1)
{
//if casting is false - start
if cast = false
{



/*
//Stop the bumping fix - start
been_bumped = false;
alarm[5] = 0;
//Stop the bumping fix - end
*/
//Moving - start
if selected = true
{
    if attack_mode = true || attack_target != 99 //cancels and attacking
    {
        attack_target = 99;
        attack_mode = false;
    }
    if gathering = true
    {
        gathering = false;
        if (toggle_resource) {grout_target.num_harvesting--; toggle_resource = !toggle_resource} // Boolean to determine how many harvesters on one resource
    }
    if build_ing = true
    {
        build_ing = false;
    }
    //NEW ADVANCED MOVEMENT - DISBEGEE COMMIT: Had to disable this, caused some sort of obj_selector bug
    
    if global.mapMovement == 1
    {

    //Testing for minimap movement
    //Code successfully implemented in obj_selector Glob Right Pressed
        /*move_x = global.mapMove_x;
        move_y = global.mapMove_y;*/
    }
    else
    {
        mask_width = bbox_right - bbox_left
        mask_height = bbox_bottom - bbox_top
        //DBG edits into mask_width and height in order to "center" right click movement
        /*
        move_x = mouse_x + mask_width/2;
        move_y = mouse_y // + mask_height/2;
        */
    }
    //
    able_to_move = true;
    alarm[6]=1;
}
//Moving - end

//Attacking - start
if selected = true
{
    var attackable = false;
    var selected_enemy;
    for (i=0;i&lt;hostile_units_num;i++) {
        selected_enemy = instance_place(mouse_x,mouse_y,hostile_units[i])
        
        if (selected_enemy) {
            attackable = true;
            break;
        }
        
    }
      
//    if instance_place(mouse_x,mouse_y,attackable_units) &amp;&amp; global.mapMovement == 0
    if attackable &amp;&amp; global.mapMovement == 0
    {
        if attack_mode = true || attack_target != 99 
        {
            attack_target = 99;
            attack_mode = false;
        }
        //test to see if this fixes bug
        if able_to_move = true
        {
            able_to_move = false;
            speed = 0
            state = 0;
        }
        //test to see if this fixes bug
        //new - might cause bugs
        if gathering = true
        {
            gathering = false;
        }
        if build_ing = true
        {
            build_ing = false;
        }
        //new - might cause bugs
        //selected_enemy = instance_place(mouse_x,mouse_y,attackable_units);
        attack_target = selected_enemy;
        attack_mode = true;
        able_to_move = false; //DBG - changed from false
        move_x = mouse_x;
        move_y = mouse_y;
        alarm[6] = 1
    }
}
//Attacking - end

//Peoning - start
if selected = true &amp;&amp; ispeon = true
{
    if instance_place(mouse_x,mouse_y,obj_resource_parent) &amp;&amp; global.mapMovement == 0
    {
        //new - could cause bugs - just cancels attacking and building
        if attack_mode = true || attack_target != 99 //cancels and attacking
        {
            attack_target = 99;
            attack_mode = false;
        }
        if build_ing = true
        {
            build_ing = false;
        }
        //new - could cause bugs - just cancels attacking and building
        //gather information for gathering routine
        tmp_res = instance_place(mouse_x,mouse_y,obj_resource_parent);
        grout_type = tmp_res.type;
        //grout_collect = tmp_res.resource_num;
        switch(tmp_res.resource_num)
        {
            case 1:{grout_collect = res_hold1;}break;
            case 2:{grout_collect = res_hold2;}break;
            case 3:{grout_collect = res_hold3;}break;
            case 4:{grout_collect = res_hold4;}break;
            case 5:{grout_collect = res_hold5;}break;
        }
        grout_resnum = tmp_res.resource_num;
        grout_target = tmp_res;
        grout_object = tmp_res.object_index;
        res_x = tmp_res.x;
        res_y = tmp_res.y;
        grout_deposit = instance_nearest(x,y,grout_peonhouse/*temp*/); //clostest peon building structure
        //enter gathering routine
        gathering = true;
    }
}
//Peoning - end

//Building - start
if selected = true &amp;&amp; iscratorer = true
{
    if instance_place(mouse_x,mouse_y,build_ables) &amp;&amp; global.mapMovement == 0
    {
        build_target = instance_place(mouse_x,mouse_y,build_ables);
        if build_target.is_built = false &amp;&amp; build_target.is_placed = true
        {
            //new - could cause bugs - just cancels attacking and gathering
            if able_to_move = true
            {
                able_to_move = false;
            }
            if attack_mode = true || attack_target != 99 //cancels and attacking
            {
                attack_target = 99;
                attack_mode = false;
            }
            if gathering = true
            {
                gathering = false;
            }
            //end new - could cause bugs - just cancels attacking and gathering
            buildn_x = build_target.x;
            buildn_y = build_target.y;
            build_ing = true;
        }
    }
}
//Building - end


}
// if casting is false - end
}
// mouse not in hud - end
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>collide_building = collision_ellipse(bbox_left,bbox_top,bbox_right,bbox_bottom,obj_building_parent_multi,false,true)
collide_gathering = 0
while (all_collision_ellipse(bbox_left,bbox_top,bbox_right,bbox_bottom,obj_unit_parent,false,true)) {
    if (global._id.collecting) {
        collide_gathering = global._id
    }
}


if (!collide_building &amp;&amp; !collide_gathering) {
    speed = 0
    able_to_move = false
    exit;
}


alarm[4] = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//this is for cast time
//execute_string(cast_code);
script_execute(cast_code);
casting = false;
cast = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//faction changing

//New variable to deprecate "attackable_units"
hostile_units[0] = "";
hostile_units_num = 0;
var tempstring
var tempobj

for (i=0;i&lt;global.ServerPlyrCnt+1;i+=1) {
    if (global.Player[i] == ENEMY) {
        tempstring = "obj_p" + string(i) + "_unit_parent";
        tempobj = asset_get_index(tempstring);
        
        hostile_units[hostile_units_num] = tempobj
        hostile_units_num += 1;
        
        tempstring = "obj_p" + string(i) + "_building_parent";
        tempobj = asset_get_index(tempstring)
        
        hostile_units[hostile_units_num] = tempobj
        hostile_units_num += 1;
    }
}



//todo with movement
/*if able_to_move = true || gathering = true
{
//if move_x - instance_nearest(move_x,move_y,all).x &lt;= unit_area &amp;&amp; move_x - instance_nearest(move_x,move_y,all).x &gt;= (-1*unit_area) &amp;&amp; move_y - instance_nearest(move_x,move_y,all).y &lt;= unit_area &amp;&amp; move_y - instance_nearest(move_x,move_y,all).y &gt;= (-1*unit_area)
/*        if distance_to_object(poopoo) &lt;= 0
        {
            able_to_move = true;
            move_x = move_x + random(32) - random(32);
            move_y = move_y + random(32) - random(32);
        }
}*/
/*
if selected = true &amp;&amp; iscratorer = true &amp;&amp; secondrun = 0
{
    building_x = mouse_x
    building_y = mouse_y
    secondrun = 1
    alarm[2] = 1
}
*/
/*
if selected = true &amp;&amp; iscratorer = true
{
    if instance_place(building_x,building_y,build_ables) &amp;&amp; global.mapMovement == 0
    {
        build_target = instance_place(building_x,building_y,build_ables);
        if build_target.is_built = false &amp;&amp; build_target.is_placed = true
        {
            //new - could cause bugs - just cancels attacking and gathering
            if able_to_move = true
            {
                able_to_move = false;
            }
            if attack_mode = true || attack_target != 99 //cancels and attacking
            {
                attack_target = 99;
                attack_mode = false;
            }
            if gathering = true
            {
                gathering = false;
            }
            //end new - could cause bugs - just cancels attacking and gathering
            buildn_x = build_target.x;
            buildn_y = build_target.y;
            build_ing = true;
            
            able_to_move = true;
            alarm[6] = 1;
            global.buildingbuilding = false
        }
    }
 
}


/*
if selected = true &amp;&amp; iscratorer = true &amp;&amp; secondrun = true {

    if instance_place(building_x,building_y,build_ables) &amp;&amp; global.mapMovement == 0 
    {
        build_target = instance_place(building_x,building_y,build_ables);
            if build_target.is_built = false
            {
                //new - could cause bugs - just cancels attacking and gathering
                if able_to_move = true
                {
                    able_to_move = false;
                }
                if attack_mode = true || attack_target != 99 //cancels and attacking
                {
                    attack_target = 99;
                    attack_mode = false;
                }
                if gathering = true
                {
                    gathering = false;
                }
                //new - could cause bugs - just cancels attacking and gathering
                buildn_x = build_target.x;
                buildn_y = build_target.y;
                build_ing = true;
                
                if distance_to_object(build_target) &lt;= 2
                    {
                        state = 6;
                        if (ownerId == global.PlayerId) // Network
                        {
                            build_target.build_progress += build_power;
                        }
                    }
                else
                {
                    state = 1;
                    move_x = buildn_x;
                    move_y = buildn_y;
                    //mp_potential_step(buildn_x,buildn_y,unit_speed,false);
                } 
            }
    } 
    secondrun = false
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>can_gather = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>can_attack = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//depth = -y

if cliff_sight {
    depth = -y-room_height
}
else {
    depth = -y
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Fog of War - start

//if (!object_is_ancestor(self.object_index,obj_enem_parent))
if (team != ENEMY)
{
    if (global.PlayerId == ownerId) {
        ghost_ID.x = x
        ghost_ID.y = y
    }
    //Cliff c
    
    //if (tile_layer_find(999999,x,y) &gt; 10000) { // If it CAN see on cliffs
    if (collision_point(x,y,EntireCliffs,true,true)) {
    //if (collision_circle(x,y - (y_offset),sprite_width / 2,EntireCliffs,true,true)) {
        
        
       
        /*
        if !(ds_list_find_index(obj_new_fog_of_war.cliff_list,id) &gt;= 0) {
            ds_list_add(obj_new_fog_of_war.cliff_list,id)
            ds_list_add(obj_new_fog_of_war.cliff_list_x,x)
            ds_list_add(obj_new_fog_of_war.cliff_list_y,y)
        }
        */
        /*
        if (cliff_yet = 0) {
            obj_new_fog_of_war.array_cliff_units[obj_new_fog_of_war.acu] = id
            cliff_yet = 1
            obj_new_fog_of_war.acu += 1
        }
        */
        
        cliff_sight=true
        
        /*
        if (instance_exists(unit_cliff_id)) {              //If it can see on cliffs and it already has unit_cliff_id following it
        
        }
        
        else {                                          //If it can see on cliffs BUT has no one following it
        
            //Create the instance obj_unit_cliff
            unit_cliff_id = instance_create(x,y,obj_unit_cliff)
            unit_cliff_id.followid = id;
        
        }
        */
        //Surface drawing on cliff-specific surface
        surface_set_target(global.cliff_fog);
        draw_set_blend_mode(bm_subtract);
        draw_set_alpha(1);
        draw_sprite(UnitFogOfWar,0,x/2,y/2);
        //draw_ellipse((x-300)/2,(y-150)/2,(x+300)/2,(y+150)/2,false)
        draw_set_blend_mode(bm_normal);
        surface_reset_target();
        
        
    } 
    
    else {                      //If NOT on cliff tile
        /*
        obj_new_fog_of_war.arrayx[(floor(x/64)*64)] = false
        obj_new_fog_of_war.arrayy[floor(y/32)*32] = false
        */
        cliff_sight = false
        if (instance_exists(unit_cliff_id)) {      //If not on cliff tile and unit_cliff_id exists....
        
            with (unit_cliff_id) {
                instance_destroy();
            }
        }
        
    } 
    surface_set_target(global.fog);
    draw_set_blend_mode(bm_subtract);
    draw_set_alpha(1);
    draw_sprite(UnitFogOfWar,0,x/2,y/2);
    draw_set_blend_mode(bm_normal);
    surface_reset_target();
    
// Fog of War - End

// Fog of War Minimap - Start

    surface_set_target(global.minifog);
    ex = (obj_minimap.length/room_width) * x;
    why = (obj_minimap.height/room_height) * y;
    viewwidth = 400 * (obj_minimap.length/room_width); //obj_new_fog_of_war distance from unit TIMES minimap width TIMES minimap scale
    draw_set_blend_mode(bm_subtract);
    draw_set_alpha(1);
    draw_circle(ex,why,viewwidth,false);
    //draw_circle(view_xview[0]+(obj_minimap.xpos+ex),view_yview[0]+(obj_minimap.ypos+why),10,false);
    //draw_sprite(FogOfWar,1,x,y);
    draw_set_blend_mode(bm_normal);
    surface_reset_target();

}

// Cliff_Sight for enemies
else {
    if (collision_point(x,y,EntireCliffs,true,true)) {
        cliff_sight = true;
    }
    else {
        cliff_sight = false;
    }

}

// Fog of War Minimap - End


    /*if x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt;= room_width &amp;&amp; y &lt;= room_height
    {
        
        //draw_set_color(obj_minimap.ally_col);
        ex = (obj_minimap.length/room_width) * x;
        why = (obj_minimap.height/room_height) * y;
        surface_set_target(global.minifog);
        draw_set_blend_mode(bm_subtract);
        draw_set_alpha(1);
        draw_rectangle(view_xview[0]+(obj_minimap.xpos+(ex-1)),view_yview[0]+(obj_minimap.ypos+(why-1))+(10),view_xview[0]+(obj_minimap.xpos+(ex+1)),view_yview[0]+(obj_minimap.ypos+(why+1))+(10),false);
        draw_set_blend_mode(bm_normal);
        surface_reset_target();
        /*surface_set_target(obj_minimap.fog);
        draw_set_blend_mode(bm_subtract);
        draw_set_alpha(1);
        draw_circle(view_xview[0]+(obj_minimap.xpos+(ex-1)),view_yview[0]+(obj_minimap.ypos+(why-1))+(10),10,0); // &lt;-Drawing circle DEBUG
        draw_set_blend_mode(bm_normal);
        surface_reset_target();

        
    }*/
// Fog of War Mini - End




// Health - start

if unit_hp  &lt;= 0 
{ 
    if selected = true 
    { 
        selected = false;
        global.number_of_selected -= 1 
    } 
    //death animation here
    instance_create(x,y,obj_explo_2);
    

    
    instance_destroy(); 
}
else if (unit_hp &gt; unit_hp_max)
{
    unit_hp = unit_hp_max;
}
// Health - end

//Ailments - start
if (ailment_count &gt;0)
{
    //ailment ticks
    if (stun_counter &gt; 0)
    {
        stun_counter -= 1;
        //turn off everything!!
        /*able_to_move = false;
        cast = false;
        casting = false;
        attack_mode = false;
        gathering = false;
        build_ing = false;*/
    }
    else
    {
        if (stunned==true)
        {
            stunned = false;
            ailment_count -= 1;
        }
    }

    if (scilence_counter &gt; 0)
    {
        scilence_counter -= 1;
    }
    else
    {
        if (scilenced==true)
        {
            scilenced = false;
            ailment_count -= 1;
        }
    }
    //ailment ticks
    
    //ailments graphics
    trnmp_counter = 0;
    
    for (i=0;i&lt;ailment_count;i+=1) //reset list
    {
        ailment_list[i] = 99;
    }
    
    //add ailments into list
    if (stunned==true) { ailment_list[trnmp_counter]=stun_spr; trnmp_counter +=1 }
    if (scilenced==true) { ailment_list[trnmp_counter]=scilence_spr; trnmp_counter +=1 }
    
    //ailments graphics
}
//Ailments - end




//Check if stunned or similar - start
if (stunned==false)
{

/* DBG Moving recode START! */

//If destination reached
gx=move_x//floor(move_x/32)*32+16;
gy=move_y//floor(move_y/32)*32+16;
if (point_distance(x,y,gx,gy) &lt; 20 * 1.5)
{

    able_to_move = false;
    //state = 0;
    just_created = false
}

//Determines which animation to use. If moving, use moving animation (state 1)
if (able_to_move == true &amp;&amp; attack_mode == false &amp;&amp; build_ing == false &amp;&amp; cast == false) {
    state = 1
}

//Collision:
collide = collision_ellipse(bbox_left,bbox_top,bbox_right,bbox_bottom,obj_unit_parent,false,true)

//New ifs for collision_building

if (!collide &amp;&amp; collide_building) {
    collide = collide_building
}
/* //Different approach to gathering
if (collide_gathering) {
    collide = collide_gathering
}
*/
//If you aint colliding or purposely moving
if (!collide &amp;&amp; !able_to_move) {
    //U aint doin SHIT
    speed = 0
    //state = 0
    just_created = false
} 

//Calculate vector for collision expectancy &amp;&amp; NEW: Calculate coll_x and y if x=x and y=y
if (collide) {
    coll_angle = (point_direction(collide.x,collide.y,x,y))
    coll_y_vec = cos(degtorad(coll_angle)) * unit_speed
    coll_x_vec = sin(degtorad(coll_angle)) * unit_speed
    coll_x = x - (collide.x - x)
    coll_y = y - (collide.y - y)
    temp_direction = direction
    
    if (collide.x = x &amp;&amp; collide.y = y) {
        //Just something I thought about randomly... The only
        //primary key identifier to differentiate them
        if (id &gt; collide) {
            coll_x = x - 10
            coll_y = y - 10
        }
        else {
            coll_x = x + 10
            coll_y = y + 10
        }
    }
    
}
debug_var = as_map_getcell(obj_map.map,ceil(x/col_width),ceil(y/row_height));
//If colliding with something and not moving **AND NOT** gathering
if (collide &amp;&amp; !able_to_move &amp;&amp; !gathering) {
    //If collide coords does NOT interfere with astar map
    gx = coll_x_vec + x
    gy = coll_y_vec + y 
    //BUG HERE recalculate as_map_getcell using blocks
    //Problem: Does not calculate diagonals...


    //New function: Attempt to use x_previous and y_previous as variables
    temp = unit_speed
    if ((as_map_getcell(obj_map.map,(x-5)/col_width,(y-5)/row_height) &lt; 0) ||
        (as_map_getcell(obj_map.map,(x+5)/col_width,(y-5)/row_height) &lt; 0) ||
        (as_map_getcell(obj_map.map,(x-5)/col_width,(y+5)/row_height) &lt; 0) ||
        (as_map_getcell(obj_map.map,(x+5)/col_width,(y+5)/row_height) &lt; 0)) {
            x = xprevious
            y = yprevious   
            unit_speed = 0
    }
    
    
    speed = unit_speed
    move_towards_point(coll_x, coll_y, unit_speed);
    unit_speed = temp
    state = 1
    if (gathering) {
        state = 5
    }

}


//If moving (triggered by scr_msgHandler)
if (able_to_move) {
    debug_var = as_path_length(path)
    
    //Initializing to prevent error
    gox = x
    goy = y
    
    //DEBUG VAR
    DEBUGVAR = as_path_length(path)

    //If there's still paths left
    if (as_path_length(path) &gt; 0) { 
        gox = as_path_nodex(path,0)*col_width;
        goy = as_path_nodey(path,0)*row_height;
        
        //New algorithm change -- VECTOR BASED MOVEMENT
        vec_angle = point_direction(x,y,gox,goy)
        vec_x = sin(degtorad(vec_angle)) * unit_speed
        vec_y = cos(degtorad(vec_angle)) * unit_speed
        
        
        // remove first node of path if we are close enough to it
        if (point_distance(x,y,gox,goy) &lt; 10 * 1.5) {
            if (as_path_length(path) &lt;= 1) {
                move_x = x
                move_y = y
                alarm[6] = 1 
                able_to_move = false
                just_created = false
            }
            else {
                as_path_removefirst(path);
            }
        }
    }
    
    //Else if it NOT colliding but still moving... stuck in speed loop; knock it out
    //Also must throw in !just_created because freshly created units were having issues
    //Also must throw in !collide_building to not... break... anything
    else if (!collide &amp;&amp; !just_created) {
        move_x = x
        move_y = y
        gox = x
        goy = y
        alarm[6] = 1 
        able_to_move = false
    }
    else if (gathering) {
        move_x = res_x
        move_y = res_y
    }
    // I don't even know anymore i"m just coding for the hell of it
    else {
    /*
        gox = x
        goy = y
        speed = 0
        able_to_move = false */
        able_to_move = false
    }
    
 

    
    move_towards_point(gox, goy, unit_speed);
    
    
}



//Attacking - start
//nearest_enemy = instance_nearest(x,y,attackable_units);

nearest_distance = room_width

for (i=0;i&lt;hostile_units_num;i++) {
    enemy = instance_nearest(x,y,hostile_units[i])
    distance = distance_to_object(enemy)
    if (distance &lt; nearest_distance) {
        nearest_enemy = enemy
        nearest_distance = distance
    }
}

if able_to_move = false &amp;&amp; collide &lt; 0 &amp;&amp; attack_mode = false &amp;&amp; gathering = false { state = 0; } //this is a fix - its stops the unit walking iif the enmy sunndenly disappears
//if able_to_move = false &amp;&amp; gathering = false { state = 0; } //this is a fix - same as above but for gathering
// added 'gathering' check recently (jan 2013) may cause problems??
if able_to_move = false &amp;&amp; state = 0 &amp;&amp; attack_target = 99 &amp;&amp; attack_mode = false /* new */ &amp;&amp; build_ing = false &amp;&amp; gathering == false /* new */ &amp;&amp; casting == false &amp;&amp; cast==false //setting target if doing nothing and enemy is close
{
    temp_enemy = nearest_enemy;
    if distance_to_object(temp_enemy) &lt; autoattack_range
    {
        if instance_exists(temp_enemy)
        {
            if (ownerId == global.PlayerId) // disable this for other players (Network code - check)
            {
                attack_target = temp_enemy;
                tmp_enmy = temp_enemy;
            } // (Network code - check)
        }
    }
}

if instance_exists(attack_target) = 0
{
    attack_target = 99;
    attack_mode = false;
}

if attack_target != 99 //setting unit into attack mode
{
    attack_mode = true // attacking
}

//If target is already found, then initiate aggro sequence (if target is close range)
if attack_mode = true &amp;&amp; distance_to_object(attack_target) &gt; attack_range &amp;&amp; casting == false &amp;&amp; cast==false
{

    
    if alarm[6] = 0 &amp;&amp; attack_target.able_to_move{ //if enemy unit is constantly moving
        move_x = attack_target.x
        move_y = attack_target.y
        alarm[6] = 100  //DONT UPDATE PATH TOO MUCH. CAUSES LOW LEVEL .DLL PROBLEMS (UNFIXABLE) AND PATH IS INEFFICIENT AND SQUARE
    }
    
    else if (move_x != attack_target.x || move_y != attack_target.y) {
        move_x = attack_target.x
        move_y = attack_target.y
        alarm[6] = 1
    }
    
    
    if (as_path_length(path) &gt; 0) { 
        // tell us to move toward first node in path
        gox = as_path_nodex(path,0)*col_width;
        goy = as_path_nodey(path,0)*row_height;
        // remove first node of path if we are close enough to it
            if (point_distance(x,y,gox,goy) &lt;= 10 * 1.5) {
                as_path_removefirst(path);
            }
        
        move_towards_point(gox, goy, unit_speed);
    
    }
    

    
    //else  { //if alarm6 = 0
        
    //}
    
    state = 1; 
}
//actual attack cycle **
if attack_mode = true &amp;&amp; distance_to_object(attack_target) &lt;= attack_range &amp;&amp; casting == false
{
    if instance_exists(attack_target)
    {
        direction = point_direction(x,y,attack_target.x,attack_target.y); //makes them look at the bloody enemy
        
        //Collision with attack object
        if (collide &gt; 0) {
            //If collide coords does NOT interfere with astar map
            gx = coll_x_vec + x
            gy = coll_y_vec + y 
            //BUG HERE recalculate as_map_getcell using blocks
            //Problem: Does not calculate diagonals...
        
        
            //New function: Attempt to use x_previous and y_previous as variables
            temp = unit_speed
            if ((as_map_getcell(obj_map.map,(x-5)/col_width,(y-5)/row_height) &lt; 0) ||
                (as_map_getcell(obj_map.map,(x+5)/col_width,(y-5)/row_height) &lt; 0) ||
                (as_map_getcell(obj_map.map,(x-5)/col_width,(y+5)/row_height) &lt; 0) ||
                (as_map_getcell(obj_map.map,(x+5)/col_width,(y+5)/row_height) &lt; 0)) {
                    x = xprevious
                    y = yprevious   
                    unit_speed = 0
            }
            
            
            speed = unit_speed
            move_towards_point(coll_x, coll_y, unit_speed);
            unit_speed = temp
            state = 1
        }
        
        switch (attack_type)
        {
            case 0:
            {
                if can_attack = true
                {
                    alarm[0] = attack_cooldown;
                    //tmp_enmy.unit_hp -= unit_damage; // -- this is for attempt 2 (NO!! IT HAS BEEN MOVED DOWN, i think)
                    can_attack = false;
                    able_to_move = false // changed to false
                    // --  play attack animation here please  -- 
                    //atempt 1 - start (still keep for attempt 2)
                    state = 2;
                    image_index = 0;
                    image_speed = 0.5;
                    //atemp1 - end
                }
            }
            break;
        
            case 1:
            {
                if can_attack = true
                {
                    alarm[0] = attack_cooldown;
                    can_attack = false;
                    state = 2;
                    image_index = 0;
                    image_speed = 0.5;
//moved down        //actuall ranged stuff goes here
//so you would be   //tmp_rng = instance_create(x,y,attack_range_obj);
//able to chose when//tmp_rng.fastness = attack_range_speed;
//the proj was shot //tmp_rng.targetx = tmp_enmy.x;//to make this homeing just use tmp_enemy.x in the projectile object
//                  //tmp_rng.targety = tmp_enmy.y;//to make this homeing just use tmp_enemy.x in the projectile object
//                  //tmp_rng.target = tmp_enmy;
                    //tmp_rng.damage = unit_damage_range;
                    //tmp_rng.aoe = attack_range_AOE;
                    //tmp_rng.init_dir = direction;
                }
            }
            break;
        
            case 2:
            {
            }
            break;
        }
    }
    
    //do to with attack animimations looping and stopping
    switch (attack_type)
    {
        case 0: // melee or close
        {
            //attampt 1 - start (still keep for attempt 2)
            if state = 2 &amp;&amp; image_index = atk_spr_length
            {
                state = 0;
                image_speed = 0;
                image_index = 0;
            }
            //attempt 1 - end
            //attampt 2 - start
            if state = 2 &amp;&amp; image_index = atk_spr_hit
            {
                //attack_target.unit_hp -= unit_damage; //old non-multiplayer damage
                /* - network -*/
                // send damage message
                if (global.PlayerId = ownerId) // if is player owns this unit
                {
                    write_ushort(global.ServerSocket,22) //message id: forward message to single client
                    write_ubyte(global.ServerSocket,6) //message size
                    write_ubyte(global.ServerSocket,attack_target.ownerId) //recipient
                    write_ushort(global.ServerSocket,1002) //message id: update for damage
                    write_ushort(global.ServerSocket,attack_target.netId) //unit id (netid)
                    write_short(global.ServerSocket,unit_damage) //damage taken
                }
                /* - network -*/
            }
            //attempt 2 - end
        }
        break;
        case 1: // long range attacks
        {
            if state = 2 &amp;&amp; image_index = atk_spr_length
            {
                state = 0;
                image_speed = 0;
            }
            if state = 2 &amp;&amp; image_index = atk_spr_rng_hit
            {
            //actuall ranged stuff goes here
                tmp_rng = instance_create(x+atk_proj_x[dir],y+atk_proj_y[dir],attack_range_obj);
                tmp_rng.fastness = attack_range_speed;
                tmp_rng.targetx = attack_target.x;//to make this homeing just use tmp_enemy.x in the projectile object
                tmp_rng.targety = attack_target.y;//to make this homeing just use tmp_enemy.x in the projectile object
                tmp_rng.target = attack_target;
                tmp_rng.damage = unit_damage_range;
                tmp_rng.aoe = attack_range_AOE;
                tmp_rng.init_dir = direction;
                tmp_rng.owner = ownerId; //NEW - for Network purposes
            }
        }
    }
}
//actual attack cycle **
//Attacking - end

//Gathering - start
if ispeon = true &amp;&amp; gathering = true
{
    if holding_resources = true //If currently collecting / Going to base -- Start
    {
        if grout_collect &lt; res_hold_lim //Currently collecting / Have some mats but need to fill up
        {
            if instance_exists(grout_target)
            {
                move_x = res_x;
                move_y = res_y;
                able_to_move = true;
                collecting = true; // New - For Network
                if distance_to_object(grout_target) &lt;= grout_target.area_size //Currently collecting
                {
                    // Boolean to determine how many harvesters on one resource
                    if (!toggle_resource) {grout_target.num_harvesting++; toggle_resource = true} 
                    
                    able_to_move = false;
                    direction = point_direction(x,y,grout_target.x,grout_target.y); //makes them look at the bloody enemy
                    
                    //Collision code... Inject HERE
                    /*
                    while (all_collision_ellipse(bbox_left,bbox_top,bbox_right,bbox_bottom,obj_unit_parent,false,true)) {
                        if (global._id.collecting) {
                            collide_gathering = global._id
                            alarm[4] = 1
                        }
                    }
                    */
                    
                    if can_gather = true // ACUTAL Gather Cycle *************** start
                    {
                        alarm[1] = gathercooldown;
                        can_gather = false;
                        holding_resources = true;
                        state = 3;
                        image_index = 0;
                        image_speed = 0.5;
                        speed = 0;
                    }     
                    switch (grout_type) // to do with animations
                    {
                        case 0:
                        {
                            if state = 3 &amp;&amp; image_index = gath_spr_length
                            {
                                state = 0;
                                image_speed = 0;
                            }
                            if state = 3 &amp;&amp; image_index = gath_spr_hit
                            {
                                if (ownerId == global.PlayerId) // Network
                                {
                                    grout_target.resource_amount -= gather_rate;
                                    grout_collect += gather_rate;
                                }
                            }
                        }
                        break;
                        case 1:
                        {
                            if (ownerId == global.PlayerId) // Network
                            {
                                grout_target.resource_amount -= res_hold_lim;
                                grout_collect += res_hold_lim;
                            }
                        }
                        break;
                    }
                       // ACUTAL Gather Cycle *************** end
                }
            }
        }
        else
        if grout_collect &gt;= res_hold_lim //If load is full
        {
            if instance_exists(grout_deposit)
            {
                move_x = grout_deposit.x
                move_y = grout_deposit.y
                able_to_move = true;
                state = 5;
                collecting = false; // New - For Network
                if distance_to_object(grout_deposit) &lt;= grout_deposit.area_size
                {
                    {
                        /*switch(grout_resnum)
                        {
                            case 1:{res_hold1 = grout_collect;}break;
                            case 2:{res_hold2 = grout_collect;}break;
                            case 3:{res_hold3 = grout_collect;}break;
                            case 4:{res_hold4 = grout_collect;}break;
                            case 5:{res_hold5 = grout_collect;}break;
                        }*/
                        if (ownerId == global.PlayerId) // Network
                        {
                            obj_resource_manager.res1 += res_hold1;
                            obj_resource_manager.res2 += res_hold2;
                            obj_resource_manager.res3 += res_hold3;
                            obj_resource_manager.res4 += res_hold4;
                            obj_resource_manager.res5 += res_hold5;
                            res_hold1 = 0;
                            res_hold2 = 0;
                            res_hold3 = 0;
                            res_hold4 = 0;
                            res_hold5 = 0;
                        }
                    }
                    holding_resources = false;
                    grout_collect = 0;
                    able_to_move = false;
                    switch_to_resource = true;
                }
            }
            if instance_exists(grout_target) {
                if (toggle_resource) {grout_target.num_harvesting--; toggle_resource = false} // Boolean to determine how many harvesters on one resource
            }
            toggle_resource = false
        }    
    } //If currently collecting / Going to base - end
    
    else
    if holding_resources = false //If moving towards resource / About to gather at point-blank- Start
    {
        if instance_exists(grout_target) &amp;&amp; grout_target != -1 //Throwing in grout_target -1 cause for some reason instancea-exists not catching it
        {
            move_x = res_x;
            move_y = res_y;
            if (switch_to_resource) {alarm[6] = 1;switch_to_resource = false}
            able_to_move = true;
            collecting = true; // New - For Network
            

            if distance_to_object(grout_target) &lt;= grout_target.area_size  // ACUTAL Gather Cycle *************** start
            {
                //If resource target has too many people harvesting it
                if (grout_target.num_harvesting &gt;= grout_target.max_harvesting) {
                    
                    grout_target = scr_get_other_resource(grout_target.x,grout_target.y, grout_object, grout_target.id)
                    if (grout_target &gt; 0) {
                        grout_object = grout_target.object_index;
                        res_x = grout_target.x
                        res_y = grout_target.y
                        move_x = res_x
                        move_y = res_y
                    }
                }
                else {
                    if (!toggle_resource) {grout_target.num_harvesting++; toggle_resource = true} // Boolean to determine how many harvesters on one resource
                    able_to_move = false;
                    if can_gather = true
                    {
                        speed = 0
                        able_to_move = false;
                        alarm[1] = gathercooldown;
                        can_gather = false;
                        holding_resources = true;
                        state = 3;
                        image_index = 0;
                        image_speed = 0.5;
                    }            
                    switch (grout_type) // to do with animations
                    {
                        case 0:
                        {
                            if state = 3 &amp;&amp; image_index = gath_spr_length
                            {
                                state = 0;
                                image_speed = 0;
                            }
                            if state = 3 &amp;&amp; image_index = gath_spr_hit
                            {
                                if (ownerId == global.PlayerId) // Network
                                {
                                    grout_target.resource_amount -= gather_rate;
                                    grout_collect += gather_rate;
                                }
                            }
                        }
                        break;
                        case 1:
                        {
                            if (ownerId == global.PlayerId) // Network
                            {
                                grout_target.resource_amount -= res_hold_lim;
                                grout_collect += res_hold_lim;
                            }
                        }
                        break; // ACUTAL Gather Cycle *************** end
                    }
                }
            }
        }
        else
        {
            gathering = false;  //** not checked - possible problem area
            able_to_move = false;
        }
    } //If moving towards resource / About to gather at point blank - End
    
    //If resource is dead - Start
    if instance_exists(grout_target) = false
    {
        temp = instance_nearest(res_x + random(4) - random(4), res_y + random(4) - random(4), grout_object)    
    
        if distance_to_object(temp) &lt;= 300
        {
            grout_type = temp.type;
            //grout_collect = temp.resource_num;
            switch(temp.resource_num)
            {
                case 1:{grout_collect = res_hold1;}break;
                case 2:{grout_collect = res_hold2;}break;
                case 3:{grout_collect = res_hold3;}break;
                case 4:{grout_collect = res_hold4;}break;
                case 5:{grout_collect = res_hold5;}break;
            }
            grout_resnum = temp.resource_num;
            grout_target = temp;
            grout_object = temp.object_index;
            res_x = temp.x;
            res_y = temp.y;
            grout_deposit = instance_nearest(x,y,grout_peonhouse); //clostest peon building structure
            //enter gathering routine
            gathering = true;
        }
        else
        {
            gathering = false;
            able_to_move = false;
            if instance_exists(grout_deposit) //** not checked - possible problem area   |
            {                                 //                                        \/
                move_x = grout_deposit.x
                move_y = grout_deposit.y
                able_to_move = true;
                state = 5;
                collecting = false; // New - For Network
                if distance_to_object(grout_deposit) &lt;= grout_deposit.area_size
                {
                    {
                        /*switch(grout_resnum)
                        {
                            case 1:{res_hold1 = grout_collect;}break;
                            case 2:{res_hold2 = grout_collect;}break;
                            case 3:{res_hold3 = grout_collect;}break;
                            case 4:{res_hold4 = grout_collect;}break;
                            case 5:{res_hold5 = grout_collect;}break;
                        }*/
                        if (ownerId == global.PlayerId) // Network
                        {
                            obj_resource_manager.res1 += res_hold1;
                            obj_resource_manager.res2 += res_hold2;
                            obj_resource_manager.res3 += res_hold3;
                            obj_resource_manager.res4 += res_hold4;
                            obj_resource_manager.res5 += res_hold5;
                            res_hold1 = 0;
                            res_hold2 = 0;
                            res_hold3 = 0;
                            res_hold4 = 0;
                            res_hold5 = 0;
                        }
                    }
                holding_resources = false;
                grout_collect = 0;
                }
            }
        }
    }
    //If resource is dead -- End
    switch(grout_resnum)
    {
        case 1:{res_hold1 = grout_collect;}break;
        case 2:{res_hold2 = grout_collect;}break;
        case 3:{res_hold3 = grout_collect;}break;
        case 4:{res_hold4 = grout_collect;}break;
        case 5:{res_hold5 = grout_collect;}break;
    }
}
//Gathering - end

//Building - start
if iscratorer = true
{
    if build_ing = true
    {
        if instance_exists(build_target)
        {
            build_target.unit_creating = id
            if build_target.is_built = false
            {
                if !collide_building
                {
                    if distance_to_object(build_target) &lt;= 2
                    {
                        state = 6;
                        move_x = x;
                        move_y = y;
                        alarm[6] = 1;
                        able_to_move = false
                        if (ownerId == global.PlayerId) // Network
                        {
                            direction = point_direction(x,y,build_target.x,build_target.y)
                            build_target.build_progress += build_power;
                        }
                    }
                    
                    else
                    {
                        state = 1;
                        if (move_x != buildn_x || move_y != buildn_y) {
                            move_x = buildn_x;
                            move_y = buildn_y;
                            alarm[6] = 1
                        }
                        able_to_move = true
                        //mp_potential_step(buildn_x,buildn_y,unit_speed,false);
                        DEBUGTESTVARIABLE = 0;
                    } 
                }
                
            }
            else
            {
                build_ing = false;
            }
        }
        else
        {
            build_ing = false;
        }
    }
}
//Building - end

//Casting - start
if (cast = true)
{
    switch (cast_type)
    {
        case 0:
        {
            if (casting = false)
            {
                direction = point_direction(x, y,cast_targetx, cast_targety);
                alarm[3] = cast_time;
                casting = true;
                state = 7;
            }
        } break;
        case 1:
        {
            if (casting = false)
            {
                if ((distance_to_object(cast_target) &gt; cast_range) &amp;&amp; (distance_to_object(cast_target) != 1000000))
                {
                    mp_potential_step(cast_target.x, cast_target.y, unit_speed, false);
                    state = 1;
                }
                else
                {
                    if (!(cast_target==id))
                    {
                        direction = point_direction(x, y,cast_target.x, cast_target.y);
                    }
                    alarm[3] = cast_time;
                    casting = true;
                    state = 7;
                }
            }
        } break;
        case 2:
        {
            if (casting = false)
            {
                if (distance_to_point(cast_targetx, cast_targety) &gt; cast_range)
                {
                    mp_potential_step(cast_targetx, cast_targety, unit_speed, false);
                    state = 1;
                }
                else
                {
                    direction = point_direction(x, y,cast_targetx, cast_targety);
                    alarm[3] = cast_time;
                    casting = true;
                    state = 7;
                }
            }
        } break;
        case 3:
        {
            if (casting = false)
            {
                alarm[3] = cast_time;
                casting = true;
                state = 7;
            }
        } break;
    }
    
    if (casting = true)
    {
        state = 7;
        image_speed = 0.5;
    }
}
//Casting - end


//Check if stunned or similar - end
}




//Button Cooldowns ticks - start
for (i=0;i&lt;18;i+=1)
{
    if (hud_button_cooldown_index[i]&gt;0)
    {
        hud_button_cooldown_index[i] -= 1;
    }
}
//Button Cooldown ticks - end

//HUD - start
if selected = true &amp;&amp; global.number_of_selected = 1
{
    obj_HUD.target = self.id;
}
//HUD - end

//temp
if (able_to_move = true){image_speed=0.5;}
if (able_to_move = false &amp;&amp; state = 0){image_speed=0;}
if (able_to_move = false &amp;&amp; state = 2){image_speed=0.5;}
if (able_to_move = false &amp;&amp; state = 1){image_speed=0.5;}
if (able_to_move = false &amp;&amp; state = 3){image_speed=0.5;}
if (stunned==true){state=0;image_speed=0.5;}
if (scilenced==true){image_speed=0.5;}
//temp

/* - Network Code - start - */
if (global.PlayerId = ownerId) // if is player owns this unit
{
    send1+=1;
    if (send1&gt;sendRate1)
    {
        if (attack_mode==true) // attacking state information (2)
        {
            write_ushort(global.ServerSocket,20); //message id: broadcast message
            write_ubyte(global.ServerSocket,6);  // length of following message (in bytes)
            write_ushort(global.ServerSocket,1001); //message id: send unit attack state
            write_ushort(global.ServerSocket,netId); //unit_id (netid)
            write_ushort(global.ServerSocket,attack_target.netId); //target id (netid)
            prev_state = 2;
        }
        else if (build_ing==true) // building state information (3)
        {
            write_ushort(global.ServerSocket,20); //message header: broadcast message
            write_ubyte(global.ServerSocket,6); // message size
            write_ushort(global.ServerSocket,1003); // message header: building state information
            write_ushort(global.ServerSocket,netId); // unit id (net id)
            write_ushort(global.ServerSocket,build_target.netId); // building id (net id)
            prev_state = 3;
        }
        else if (gathering==true) // gathering state information (4,5)
        {
            if (collecting)
            {
                write_ushort(global.ServerSocket,20); //message id: broadcast message
                write_ubyte(global.ServerSocket,8);  // length of following message (in bytes)
                write_ushort(global.ServerSocket,1004); // message header: collecting resource state
                write_ushort(global.ServerSocket,netId); //unit id (netid)
                write_uint(global.ServerSocket,grout_target); //resource id
                prev_state = 4;
            }
            else
            {
                write_ushort(global.ServerSocket,20); //message id: broadcast message
                write_ubyte(global.ServerSocket,6);  // length of following message (in bytes)
                write_ushort(global.ServerSocket,1005); // message header: storing resource state
                write_ushort(global.ServerSocket,netId); //unit id (netid)
                write_ushort(global.ServerSocket,grout_deposit.netId); //peonhouse id (netid)
                prev_state = 5;
            }
        }
        else if (cast==true) // casting state information (6,7,8)
        {
            if (casting==true)
            {
                write_ushort(global.ServerSocket,20); //message id: broadcast message
                write_ubyte(global.ServerSocket,4);  // length of following message (in bytes)
                write_ushort(global.ServerSocket,1006); // message header: casting state information
                write_ushort(global.ServerSocket,netId); //unit id (netid)
                prev_state = 6;
            }
            else
            {
                if (cast_type==1)
                {
                    write_ushort(global.ServerSocket,20); //message id: broadcast message
                    write_ubyte(global.ServerSocket,6);  // length of following message (in bytes)
                    write_ushort(global.ServerSocket,1007); // message header: cast type 1 state information
                    write_ushort(global.ServerSocket,netId); //unit id (netid)
                    write_ushort(global.ServerSocket,cast_target.netId); //cast target id (netid)
                    prev_state = 7;
                }
                else if (cast_type==2)
                {
                    write_ushort(global.ServerSocket,20); //message id: broadcast message
                    write_ubyte(global.ServerSocket,8);  // length of following message (in bytes)
                    write_ushort(global.ServerSocket,1008); // message header: cast type 2 state information
                    write_ushort(global.ServerSocket,netId); //unit id (netid)
                    write_short(global.ServerSocket,cast_targetx); // targetx
                    write_short(global.ServerSocket,cast_targety); // targety
                    prev_state = 8;
                }
            }
        }
        else if (able_to_move==true) // moving state information (1)
        {
            write_ushort(global.ServerSocket,20); //message id: broadcast message
            write_ubyte(global.ServerSocket,12);  // length of following message (in bytes)
            write_ushort(global.ServerSocket,1000); //message id: send unit move state
            write_ushort(global.ServerSocket,netId); //unit_id
            write_short(global.ServerSocket,move_x);
            write_short(global.ServerSocket,move_y);
            write_short(global.ServerSocket,x);
            write_short(global.ServerSocket,y);
            prev_state = 1;
        }
        else /*if (state==0)*/ // standing still state information (0)
        {
            if (prev_state!=0)
            {
                write_ushort(global.ServerSocket,20); //message id: broadcast message
                write_ubyte(global.ServerSocket,8);  // length of following message (in bytes)
                write_ushort(global.ServerSocket,1020); //message id: sync unit pos
                write_ushort(global.ServerSocket,netId) //unit id (netId)
                write_short(global.ServerSocket,x);
                write_short(global.ServerSocket,y);
                prev_state = 0;
            }
        }
        
        send1 = 0;
    }
    send2 += 1;
    if (send2&gt;sendRate2)
    {
        //sending something slower
        // re-sync position
        if (prev_state!=0) //only re-sync if doing something
        {
            write_ushort(global.ServerSocket,20); //message id: broadcast message
            write_ubyte(global.ServerSocket,8);  // length of following message (in bytes)
            write_ushort(global.ServerSocket,1020); //message id: sync unit pos
            write_ushort(global.ServerSocket,netId)
            write_short(global.ServerSocket,x);
            write_short(global.ServerSocket,y);
        }
        
        send2 = 0;
    }
}
/* - Network Code - end- */
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="56">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.PlayerId != ownerId) { exit; } //check that player owns unit
//if mouse is not in hud - start
//if ((mouse_y - view_yview[0]) &lt;= obj_HUD.border) &amp;&amp; (obj_minimap.active==false)
if (obj_minimap.active==false)
{



//Selection - start
if obj_selector.draw = true &amp;&amp; selected = false
{
    if x&gt;obj_selector.mousex &amp;&amp; x&lt;mouse_x &amp;&amp; y&gt;obj_selector.mousey &amp;&amp; y&lt;mouse_y { selected = true; global.number_of_selected += 1; }
    if x&lt;obj_selector.mousex &amp;&amp; x&gt;mouse_x &amp;&amp; y&gt;obj_selector.mousey &amp;&amp; y&lt;mouse_y { selected = true; global.number_of_selected += 1; }
    if x&gt;obj_selector.mousex &amp;&amp; x&lt;mouse_x &amp;&amp; y&lt;obj_selector.mousey &amp;&amp; y&gt;mouse_y { selected = true; global.number_of_selected += 1; }
    if x&lt;obj_selector.mousex &amp;&amp; x&gt;mouse_x &amp;&amp; y&lt;obj_selector.mousey &amp;&amp; y&gt;mouse_y { selected = true; global.number_of_selected += 1; }
}
//Selection - end



}
// mouse not in hud - end

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="54">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/* //Changing movement to obj_selector Global Rightpressed and Alarm[5]

if (global.PlayerId != ownerId) { exit; } //check that player owns unit
//if mouse is not in hud - start
if ((mouse_y - view_yview[0]) &lt;= obj_HUD.border || global.mapMovement == 1)
{
//if casting is false - start
if cast = false
{


//Moving - start
if selected = true
{
    if attack_mode = true || attack_target != 99 //cancels and attacking
    {
        attack_target = 99;
        attack_mode = false;
    }
    if gathering = true
    {
        gathering = false;
    }
    if build_ing = true
    {
        build_ing = false;
    }
    //NEW ADVANCED MOVEMENT - DISBEGEE COMMIT: Had to disable this, caused some sort of obj_selector bug
    
    if global.mapMovement == 1
    {

    //Testing for minimap movement
        move_x = global.mapMove_x;
        move_y = global.mapMove_y;
    }
    else
    {
        mask_width = bbox_right - bbox_left
        mask_height = bbox_bottom - bbox_top
        //DBG edits into mask_width and height in order to "center" right click movement
        move_x = mouse_x + mask_width/2;
        move_y = mouse_y // + mask_height/2;
    }
    //
    able_to_move = true;
    alarm[6]=1;
}
//Moving - end

//Attacking - start
if selected = true
{
    var attackable = false;
    var selected_enemy;
    for (i=0;i&lt;hostile_units_num;i++) {
        selected_enemy = instance_place(mouse_x,mouse_y,hostile_units[i])
        
        if (selected_enemy) {
            attackable = true;
            break;
        }
        
    }
      
//    if instance_place(mouse_x,mouse_y,attackable_units) &amp;&amp; global.mapMovement == 0
    if attackable &amp;&amp; global.mapMovement == 0
    {
        if attack_mode = true || attack_target != 99 
        {
            attack_target = 99;
            attack_mode = false;
        }
        //test to see if this fixes bug
        if able_to_move = true
        {
            able_to_move = false;
            speed = 0
            state = 0;
        }
        //test to see if this fixes bug
        //new - might cause bugs
        if gathering = true
        {
            gathering = false;
        }
        if build_ing = true
        {
            build_ing = false;
        }
        //new - might cause bugs
        //selected_enemy = instance_place(mouse_x,mouse_y,attackable_units);
        attack_target = selected_enemy;
        attack_mode = true;
        able_to_move = false; //DBG - changed from false
        move_x = mouse_x;
        move_y = mouse_y;
        alarm[6] = 1
    }
}
//Attacking - end

//Peoning - start
if selected = true &amp;&amp; ispeon = true
{
    if instance_place(mouse_x,mouse_y,obj_resource_parent) &amp;&amp; global.mapMovement == 0
    {
        //new - could cause bugs - just cancels attacking and building
        if attack_mode = true || attack_target != 99 //cancels and attacking
        {
            attack_target = 99;
            attack_mode = false;
        }
        if build_ing = true
        {
            build_ing = false;
        }
        //new - could cause bugs - just cancels attacking and building
        //gather information for gathering routine
        tmp_res = instance_place(mouse_x,mouse_y,obj_resource_parent);
        grout_type = tmp_res.type;
        //grout_collect = tmp_res.resource_num;
        switch(tmp_res.resource_num)
        {
            case 1:{grout_collect = res_hold1;}break;
            case 2:{grout_collect = res_hold2;}break;
            case 3:{grout_collect = res_hold3;}break;
            case 4:{grout_collect = res_hold4;}break;
            case 5:{grout_collect = res_hold5;}break;
        }
        grout_resnum = tmp_res.resource_num;
        grout_target = tmp_res;
        grout_object = tmp_res.object_index;
        res_x = tmp_res.x;
        res_y = tmp_res.y;
        grout_deposit = instance_nearest(x,y,grout_peonhouse); //clostest peon building structure
        //enter gathering routine
        gathering = true;
    }
}
//Peoning - end

//Building - start
if selected = true &amp;&amp; iscratorer = true
{
    if instance_place(mouse_x,mouse_y,build_ables) &amp;&amp; global.mapMovement == 0
    {
        build_target = instance_place(mouse_x,mouse_y,build_ables);
        if build_target.is_built = false &amp;&amp; build_target.is_placed = true
        {
            //new - could cause bugs - just cancels attacking and gathering
            if able_to_move = true
            {
                able_to_move = false;
            }
            if attack_mode = true || attack_target != 99 //cancels and attacking
            {
                attack_target = 99;
                attack_mode = false;
            }
            if gathering = true
            {
                gathering = false;
            }
            //end new - could cause bugs - just cancels attacking and gathering
            buildn_x = build_target.x;
            buildn_y = build_target.y;
            build_ing = true;
        }
    }
}
//Building - end


}
// if casting is false - end
}
// mouse not in hud - end
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.PlayerId != ownerId) { exit; } //check that player owns unit
//if mouse is not in hud - start
if ((mouse_y - view_yview[0]) &lt;= obj_HUD.border) &amp;&amp; (obj_minimap.active==false)
{



//Selection - start
if selected = true &amp;&amp; keyboard_check(vk_shift) = false &amp;&amp; distance_to_point(mouse_x,mouse_y) &gt;= 1// &amp;&amp; global.buildingbuilding = false
{
    selected = false;
    global.number_of_selected -= 1;
}
//Selection - end



}
/*
if selected = true &amp;&amp; iscratorer = true
{
    building_x = mouse_x
    building_y = mouse_y
    alarm[2] = 1
}
*/
//if mouse not in hud - end

//Building - start 
/*
if selected = true &amp;&amp; iscratorer = true
{
    
    //building_x = mouse_x
    //building_y = mouse_y
    
    
    if instance_place(mouse_x,mouse_y,build_ables) &amp;&amp; global.mapMovement == 0 
    {
        build_target = instance_place(mouse_x,mouse_y,build_ables);
            if build_target.is_built = false
            {
                //new - could cause bugs - just cancels attacking and gathering
                if able_to_move = true
                {
                    able_to_move = false;
                }
                if attack_mode = true || attack_target != 99 //cancels and attacking
                {
                    attack_target = 99;
                    attack_mode = false;
                }
                if gathering = true
                {
                    gathering = false;
                }
                //new - could cause bugs - just cancels attacking and gathering
                /*buildn_x = mouse_x;
                buildn_y = mouse_y;
                build_ing = true;
                
                if distance_to_object(build_target) &lt;= 2
                    {
                        state = 6;
                        if (ownerId == global.PlayerId) // Network
                        {
                            build_target.build_progress += build_power;
                        }
                    }
                    else
                    {
                        state = 1;
                        move_x = buildn_x;
                        move_y = buildn_y;
                        //mp_potential_step(buildn_x,buildn_y,unit_speed,false);
                    }
                    
            }
    } 
    
    
}   
    

//Building - end 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (global.PlayerId != ownerId) { exit; } //check that player owns unit
//if mouse is not in hud - start
if ((mouse_y - view_yview[0]) &lt;= obj_HUD.border)
{



// Selection - start
if selected = false
{
    selected = true;
    global.number_of_selected += 1;
}
// Selection - end



}
// mouse not in hud - end
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Selection - start
if selected = true
{
    draw_set_alpha(1);
    draw_set_color(c_lime);
    draw_ellipse(x+selectcx1,y+selectcy1,x+selectcx2,y+selectcy2,true);
}
//Selection - end

//Unit Animations - start
//- this is the old version
/*
switch (state)
{
    case 0: if direction &gt; 247 &amp;&amp; direction &lt; 292 {draw_sprite(spr_man_down,-1,x,y);}
            if direction &gt; 292 &amp;&amp; direction &lt; 332 {draw_sprite(spr_man_downright,-1,x,y);}
            if (direction &gt; 332 &amp;&amp; direction &lt; 360) or (direction &gt; 0 &amp;&amp; direction &lt; 22) {draw_sprite(spr_man_right,-1,x,y);}
            if direction &gt; 22 &amp;&amp; direction &lt; 67 {draw_sprite(spr_man_upright,-1,x,y);}
            if direction &gt; 67 &amp;&amp; direction &lt; 112 {draw_sprite(spr_man_up,-1,x,y);}
            if direction &gt; 112 &amp;&amp; direction &lt; 157 {draw_sprite(spr_man_upleft,-1,x,y);}
            if direction &gt; 157 &amp;&amp; direction &lt; 202 {draw_sprite(spr_man_left,-1,x,y);}
            if direction &gt; 202 &amp;&amp; direction &lt; 247 {draw_sprite(spr_man_downleft,-1,x,y);}
    break;
    case 1: if direction &gt; 247 &amp;&amp; direction &lt; 292 {draw_sprite(spr_man_down_walk,-1,x,y);}
            if direction &gt; 292 &amp;&amp; direction &lt; 332 {draw_sprite(spr_man_downright_walk,-1,x,y);}
            if (direction &gt; 332 &amp;&amp; direction &lt; 360) or (direction &gt; 0 &amp;&amp; direction &lt; 22) {draw_sprite(spr_man_right_walk,-1,x,y);}
            if direction &gt; 22 &amp;&amp; direction &lt; 67 {draw_sprite(spr_man_upright_walk,-1,x,y);}
            if direction &gt; 67 &amp;&amp; direction &lt; 112 {draw_sprite(spr_man_up_walk,-1,x,y);}
            if direction &gt; 112 &amp;&amp; direction &lt; 157 {draw_sprite(spr_man_upleft_walk,-1,x,y);}
            if direction &gt; 157 &amp;&amp; direction &lt; 202 {draw_sprite(spr_man_left_walk,-1,x,y);}
            if direction &gt; 202 &amp;&amp; direction &lt; 247 {draw_sprite(spr_man_downleft_walk,-1,x,y);}
    break;
    case 2: if direction &gt; 247 &amp;&amp; direction &lt; 292 {draw_sprite(spr_man_down_attack,-1,x,y);}
            if direction &gt; 292 &amp;&amp; direction &lt; 332 {draw_sprite(spr_man_downright_attack,-1,x,y);}
            if (direction &gt; 332 &amp;&amp; direction &lt; 360) or (direction &gt; 0 &amp;&amp; direction &lt; 22) {draw_sprite(spr_man_right_attack,-1,x,y);}
            if direction &gt; 22 &amp;&amp; direction &lt; 67 {draw_sprite(spr_man_upright_attack,-1,x,y);}
            if direction &gt; 67 &amp;&amp; direction &lt; 112 {draw_sprite(spr_man_up_attack,-1,x,y);}
            if direction &gt; 112 &amp;&amp; direction &lt; 157 {draw_sprite(spr_man_upleft_attack,-1,x,y);}
            if direction &gt; 157 &amp;&amp; direction &lt; 202 {draw_sprite(spr_man_left_attack_attack,-1,x,y);}
            if direction &gt; 202 &amp;&amp; direction &lt; 247 {draw_sprite(spr_man_downleft_attack,-1,x,y);}
    break;
};
*/

if (ownerId&lt;global.ServerPlyrCnt) // draw player color
{
    draw_set_alpha(0.5);
    draw_set_color(global.p_col[ownerId]);
    //draw_rectangle(x-rectangleleft, y-rectangleup, x+rectangleright, y+rectangledown, false);
    draw_ellipse(x+selectcx1+1,y+selectcy1+1,x+selectcx2-1,y+selectcy2-1,false);
}
//if (object_is_ancestor(self.object_index,obj_enem_parent)) // if enemy
if (team == ENEMY)
{
    //Red box (temp color)
    draw_set_alpha(1);
    draw_set_color(c_red);
    //draw_rectangle(x-8, y-16, x+8, y+16, true);
    draw_ellipse(x+selectcx1+1,y+selectcy1+1,x+selectcx2-1,y+selectcy2-1,false);
}
else
if (global.PlayerId!=ownerId) // if ally (not own units)
{
    //Cyan box (temp color)
    draw_set_alpha(1);
    draw_set_color(c_aqua);
    //draw_rectangle(x-8, y-16, x+8, y+16, true);
    draw_ellipse(x+selectcx1+1,y+selectcy1+1,x+selectcx2-1,y+selectcy2-1,false);
}

//Dis Be Gee's version

if (collide &gt; 0) {
    var temp_direction_two = direction
    direction = temp_direction
}

draw_set_alpha(1)
if direction &gt; 247 &amp;&amp; direction &lt; 292 {draw_sprite(state_anim[state,0],-1,x,y-y_offset); dir = 0}
if direction &gt; 292 &amp;&amp; direction &lt; 350 {draw_sprite(state_anim[state,1],-1,x,y-y_offset); dir = 1}
if (direction &gt; 350 &amp;&amp; direction &lt; 360) or (direction &gt;= 0 &amp;&amp; direction &lt; 10) {draw_sprite(state_anim[state,2],-1,x,y-y_offset); dir = 2}
if direction &gt; 10 &amp;&amp; direction &lt; 67 {draw_sprite(state_anim[state,3],-1,x,y-y_offset); dir = 3}
if direction &gt; 67 &amp;&amp; direction &lt; 112 {draw_sprite(state_anim[state,4],-1,x,y-y_offset); dir = 4}
if direction &gt; 112 &amp;&amp; direction &lt; 170 {draw_sprite(state_anim[state,5],-1,x,y-y_offset); dir = 5}
if direction &gt; 170 &amp;&amp; direction &lt; 190 {draw_sprite(state_anim[state,6],-1,x,y-y_offset); dir = 6}
if direction &gt; 190 &amp;&amp; direction &lt; 247 {draw_sprite(state_anim[state,7],-1,x,y-y_offset); dir = 7}

if (collide &gt; 0) {
    direction = temp_direction_two
}

/* - Default
if direction &gt; 247 &amp;&amp; direction &lt; 292 {draw_sprite(state_anim[state,0],-1,x,y);}
if direction &gt; 292 &amp;&amp; direction &lt; 332 {draw_sprite(state_anim[state,1],-1,x,y);}
if (direction &gt; 332 &amp;&amp; direction &lt; 360) or (direction &gt;= 0 &amp;&amp; direction &lt; 22) {draw_sprite(state_anim[state,2],-1,x,y);}
if direction &gt; 22 &amp;&amp; direction &lt; 67 {draw_sprite(state_anim[state,3],-1,x,y);}
if direction &gt; 67 &amp;&amp; direction &lt; 112 {draw_sprite(state_anim[state,4],-1,x,y);}
if direction &gt; 112 &amp;&amp; direction &lt; 157 {draw_sprite(state_anim[state,5],-1,x,y);}
if direction &gt; 157 &amp;&amp; direction &lt; 202 {draw_sprite(state_anim[state,6],-1,x,y);}
if direction &gt; 202 &amp;&amp; direction &lt; 247 {draw_sprite(state_anim[state,7],-1,x,y);}*/

//Unit animations - end

//Health Bar - start
if ((selected==true)||(distance_to_point(mouse_x, mouse_y)&lt;=0))
{
    _len = (healthbar_length*(unit_hp/unit_hp_max)); 
    draw_set_alpha(1);
    draw_set_color(healthbar_bg_col);
    draw_rectangle(x+healthbar_x,y+healthbar_y,x+healthbar_x+healthbar_length,y+healthbar_y+healthbar_height,false);
    draw_set_color(healthbar_fg_col);
    draw_rectangle(x+healthbar_x+1,y+healthbar_y+1,x+healthbar_x+_len-1,y+healthbar_y+healthbar_height-1,false);
}
//Health Bar - end

//Ailment animations - start
if (ailment_count&gt;0)
{
    startx_draw = -((ailment_count*((ailment_size*(ailment_count-1))+(ailment_gap*(ailment_count-1))))/4)
    for (i=0;i&lt;ailment_count;i+=1)
    {
        draw_sprite(ailment_list[i], -1, x+startx_draw+(i*(ailment_size+ailment_gap)), y+ailment_pos);
    }
}
//Ailment animations - end

//temp - start
//temp - if(able_to_move){draw_line(x,y,move_x,move_y);} //use this for debugging
//if direction &gt; 247 &amp;&amp; direction &lt; 292 {draw_sprite(spr_man_down_walk,-1,x,y);}
//if direction &gt; 292 &amp;&amp; direction &lt; 332 {draw_sprite(spr_man_downright_walk,-1,x,y);}
//if (direction &gt; 332 &amp;&amp; direction &lt; 360) or (direction &gt; 0 &amp;&amp; direction &lt; 22) {draw_sprite(spr_man_right_walk,-1,x,y);}
//if direction &gt; 22 &amp;&amp; direction &lt; 67 {draw_sprite(spr_man_upright_walk,-1,x,y);}
//if direction &gt; 67 &amp;&amp; direction &lt; 112 {draw_sprite(spr_man_up_walk,-1,x,y);}
//if direction &gt; 112 &amp;&amp; direction &lt; 157 {draw_sprite(spr_man_upleft_walk,-1,x,y);}
//if direction &gt; 157 &amp;&amp; direction &lt; 202 {draw_sprite(spr_man_left_walk,-1,x,y);}
//if direction &gt; 202 &amp;&amp; direction &lt; 247 {draw_sprite(spr_man_downleft_walk,-1,x,y);}
//temp - end


// Setting colors to differentiate owners of units


// temp debugging
//draw_text(x+16,y-16,string(netId));

//draw_path(mypath,x,y,0);
//draw_set_color(c_black);


//DBG draw astar path DEBUG
/*
draw_set_color(c_red);



tempx = x 
tempy = y 

for (i=0;i&lt;as_path_length(path);i++) {
    nextx = as_path_nodex(path,i) * col_width;
    nexty = as_path_nodey(path,i) * row_height;
    
    draw_line(tempx,tempy,nextx,nexty);

    tempx = nextx;
    tempy = nexty;
}


//DBG draw BOUNDING BOX debug
draw_set_color(c_red);
draw_rectangle(bbox_left,bbox_top,bbox_right,bbox_bottom,true)

//DBG draw X and Y COORDINATE debug
draw_set_color(c_green);
draw_rectangle(x-5,y-5,x+5,y+5,false)

//draw_set_color(c_gray);
//draw_rectangle(sprite_bbox_left,sprite_bbox_top,sprite_bbox_right,sprite_bbox_bottom,true)
//draw_circle(x,y - (y_offset),sprite_width / 2,true)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
