<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-9000003</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// setup
chat_x = 8; //xposition of the message, relative to the view port
chat_y = 405; //xposition of the message, relative to the view port
chat_ygap = 19; //y - gap between texts
chat_queue[0] = 99 //this array holds the list of messages to show
chat_queue_life[0] = 99; //How long each message in queue has left to live
chat_life = 200; // how long the message stays on screen
chat_cap = 15; // the max amount of messages allowed to be shown
chat_count = 0; //the amount of messages in the chat queue

chat_col = c_white; //the color of the text

chat_queue_owner[0] = 99; //owner of the corresponding message

chat_local_hotkey = vk_enter; //local chat hotkey
chat_global_modifier = vk_shift; //global chat hotkey
chat_send_hotkey = vk_enter; //hotkey for sending the message
chat_active = false;
chat_message = "99"; //holds the message to be sent

chat_limit = 100; //limit on how long messages can be
chat_width = 36; //width of the box where you enter your message into
chat_prev_hotkey = "Z" //hotkey for displaying previous messages
hotkeyCheck = false;

message_x = 252; //xpos of the area where you type the message
message_y = 433; //ypos of the area where you type the message
message_box_x = 248; //xpos of message box
message_box_y = 430; //ypos of message box
message_box_width = 400; //width of the message box
message_box_height = 25; //height of the message box
message_box_bordercol = c_navy; //color of border
message_box_bgcol = c_gray; //color of background
message_box_bgalpha = 0.6; //alpha of background
message_col = c_white;
message_font = font_chat_message; //use a monospaced font for best results

//initialise the arrays
for (i=0;i&lt;chat_cap;i+=1)
{
    chat_queue[i] = "99";
    chat_queue_life[i] = "99";
    chat_queue_owner[i] = 99;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// message sending - start
if (chat_active==false)
{
    if (keyboard_check_pressed(chat_local_hotkey))
    {
        type = "local";
        if (keyboard_check(chat_global_modifier)) type = "global";
        keyboard_string = "";
        chat_active = true;
    }
}
else
{
    //enforce message limit
    if (string_length(keyboard_string) &gt; chat_limit)
    {
        keyboard_string = string_copy(keyboard_string,0,chat_limit);
    }
    
    if (keyboard_check_pressed(chat_send_hotkey))
    {
        //put message into chat queue
        msg = keyboard_string;
        chat_active = false;
        
        if (string_length(msg)&gt;0)
        {
            for (i=(chat_cap-1);i&gt;0;i-=1) // push everything in the list back
            {
                chat_queue[i] = chat_queue[(i-1)];
                chat_queue_life[i] = chat_queue_life[(i-1)];
                chat_queue_owner[i] = chat_queue_owner[(i-1)];
            }
            chat_queue[0] = msg;
            chat_queue_life[0] = chat_life;
            chat_queue_owner[0] = global.PlayerId;
            if (chat_count&lt;chat_cap)
            {
                chat_count += 1;
            }
        
            // send others message
            write_ushort(global.ServerSocket,20); // message header: broadcast
            write_ubyte(global.ServerSocket,5+string_length(msg)) //length of message
            write_ushort(global.ServerSocket,900); //message header: chat message
            write_ubyte(global.ServerSocket,global.PlayerId) //message owner
            if (type=="global") { write_ubyte(global.ServerSocket,0); } else { write_ubyte(global.ServerSocket,global.p_team[global.PlayerId]); } //which team to send message to (0 is all players)
            write_ubyte(global.ServerSocket,string_length(msg)); // message length
            write_string(global.ServerSocket,msg) // actual message
        }
    }
}
// message sending - end

// message tick - start
if (chat_count&gt;0)
{
    for (i=0;i&lt;chat_count;i+=1) //reduce the life of all messages
    {
        if (chat_queue_life[i]&gt;0)
        {
            chat_queue_life[i] -= 1;
        }
    }
    
    counter = 0;
    for (i=0;i&lt;chat_count;i+=1) //kill all the dead messages
    {
        if (chat_queue_life[counter]&gt;0)
        {
            counter += 1;
        }
        else
        {
            chat_count -= 1;//delete chat
        }
    }
}
//message tick - end
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//display previous messages
prev = false;
if (chat_active==false)
{
    if (keyboard_check(ord(chat_prev_hotkey)))
    {
        for (i=0;i&lt;chat_cap;i+=1)
        {
            if (chat_queue_owner[i]!=99)
            {
                draw_set_alpha(1);
                draw_set_color(global.p_col[chat_queue_owner[i]]);
                draw_text(view_xview[0]+chat_x,view_yview[0]+chat_y-(i*chat_ygap),global.p_name[chat_queue_owner[i]])
                namLeng = string_width(global.p_name[chat_queue_owner[i]]) + /*padding*/ 3;
                draw_set_color(chat_col);
                draw_text(view_xview[0]+chat_x+namLeng,view_yview[0]+chat_y-(i*chat_ygap),":"+chat_queue[i]);
                prev = true; //stop drawing messages twice
            }
        }
    }
}
// draw messages
if (chat_count&gt;0 &amp;&amp; prev==false)
{
    for (i=0;i&lt;chat_count;i+=1)
    {
        draw_set_alpha(1);
        if (chat_queue_life[i]&lt;=40)
        {
            draw_set_alpha(chat_queue_life[i]/40);
        }
        draw_set_color(global.p_col[chat_queue_owner[i]]);
        draw_text(view_xview[0]+chat_x,view_yview[0]+chat_y-(i*chat_ygap),global.p_name[chat_queue_owner[i]])
        namLeng = string_width(global.p_name[chat_queue_owner[i]]) + /*padding*/ 3;
        draw_set_color(chat_col);
        draw_text(view_xview[0]+chat_x+namLeng,view_yview[0]+chat_y-(i*chat_ygap),":"+chat_queue[i]);
    }
}


// message box
if (chat_active)
{
    //message box
    draw_set_color(message_box_bgcol);
    draw_set_alpha(message_box_bgalpha);
    draw_rectangle(view_xview[0]+message_box_x,view_yview[0]+message_box_y,view_xview[0]+message_box_x+message_box_width,view_yview[0]+message_box_y+message_box_height,false);
    draw_set_color(message_box_bordercol);
    draw_set_alpha(1);
    draw_rectangle(view_xview[0]+message_box_x,view_yview[0]+message_box_y,view_xview[0]+message_box_x+message_box_width,view_yview[0]+message_box_y+message_box_height,true);
    //message
    if (string_length(keyboard_string) &gt; chat_width)
    {
        visMsg = string_copy(keyboard_string,string_length(keyboard_string)-(chat_width-1),(chat_width));
    }
    else
    {
        visMsg = keyboard_string;
    }
    if (type=="local")
    {
        draw_set_alpha(1);
        draw_set_color(message_col);
        draw_set_font(message_font);
        draw_text(view_xview[0]+message_x,view_yview[0]+message_y,"(Team):"+visMsg);
        draw_set_font(-1)//reset font to default
    }
    else
    {
        draw_set_alpha(1);
        draw_set_color(message_col);
        draw_set_font(message_font);
        draw_text(view_xview[0]+message_x,view_yview[0]+message_y,"(All):"+visMsg);
        draw_set_font(-1)//reset font to default
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
